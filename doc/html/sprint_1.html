<head>
        <link rel="stylesheet" href="../css/w3.css"> 
        <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"> 
        <!-- <link rel="stylesheet" href="../css/doc.css"> -->
</head><body>
<style>

body {
    --sidebar-width: 400px;
    padding-left: calc( var( --sidebar-width ) + 100px);
    /* max-width: 1000px; */
    padding-right: 200px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.toc-sidebar {
    position: fixed;
    margin-left: 0;
    top: 0;
    left: 0;
    width: var(--sidebar-width);
    height: 100vh;
    padding: 0;
    background-color: rgb(31, 32, 32);
    font-size: 21px;
    font-weight: bold;
    text-transform: uppercase;
}
.toc-sidebar > * {
    padding: 10px
}
.toc-sidebar > div {
    width: 100%;
    padding-top: 20px;
    padding-bottom: 20px;
}
.toc-sidebar > div:hover {
    background-color: rgb(51, 51, 51);
}
.toc-sidebar a {
    color: white;
    text-decoration: unset;
    display: inline-block;
    width: 100%;
    height: 0;
    padding-bottom: 10%;
}

/* 
h3 strong {
    color: #800080; 
} */

img {
    max-width: 100%;
    max-height: 700px;
}

.w3-code {
    overflow-x: scroll;
}</style>
<div>
  <h1 id="toc_1" class="w3-container w3-indigo">Sprint 1</h1>
  <section class="toc-sidebar">
    <div class="sidebar-index w3-deep-purple">
      <a href="./index.html">Indice generale</a>
    </div>
    <div>
      <a href="#toc_1">Sprint 1</a>
    </div>
    <div>
      <a href="#toc_3">Requirements</a>
    </div>
    <div>
      <a href="#toc_5">Analisi dei Requisiti</a>
    </div>
    <div>
      <a href="#toc_14">Analisi del problema</a>
    </div>
    <div>
      <a href="#toc_31">Progettazione</a>
    </div>
    <div>
      <a href="#toc_44">Riassunto SPRINT 1</a>
    </div>
  </section>
  <h3 id="toc_2" class="w3-container w3-green">Indice</h3>
  <section class="toc">
    <ul>
      <li>
        <a href="#toc_1">Sprint 1</a>
        <ul>
          <li>
            <a href="#toc_2">Indice</a>
          </li>
          <li>
            <a href="#toc_3">Requirements</a>
            <ul>
              <li>
                <a href="#toc_4">TFRequirements</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#toc_5">Analisi dei Requisiti</a>
            <ul>
              <li>
                <a href="#toc_6">Requisiti e chiarimenti</a>
              </li>
              <li>
                <a href="#toc_7">Glossario</a>
              </li>
              <li>
                <a href="#toc_8">Analisi dei requisiti</a>
              </li>
              <li>
                <a href="#toc_13">Scelta del linguaggio di modellazione</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#toc_14">Analisi del problema</a>
            <ul>
              <li>
                <a href="#toc_15">Componenti</a>
              </li>
              <li>
                <a href="#toc_17">Requisito deposit - La deposit action</a>
              </li>
              <li>
                <a href="#toc_22">Configurazione</a>
              </li>
              <li>
                <a href="#toc_23">Interazione</a>
              </li>
              <li>
                <a href="#toc_26">Architettura Logica</a>
              </li>
              <li>
                <a href="#toc_27">Test Plan</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#toc_31">Progettazione</a>
            <ul>
              <li>
                <a href="#toc_32">In generale</a>
              </li>
              <li>
                <a href="#toc_33">Struttura del software</a>
              </li>
              <li>
                <a href="#toc_34">Test</a>
              </li>
              <li>
                <a href="#toc_35">WasteService</a>
              </li>
              <li>
                <a href="#toc_40">Trolley</a>
              </li>
              <li>
                <a href="#toc_41">StorageManager</a>
              </li>
              <li>
                <a href="#toc_42">Struttura del sistema</a>
              </li>
              <li>
                <a href="#toc_43">Immagine Docker</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#toc_44">Riassunto SPRINT 1</a>
            <ul>
              <li>
                <a href="#toc_45">Analisi</a>
              </li>
              <li>
                <a href="#toc_46">Progetto</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </section>
  <h2 id="toc_3" class="w3-container w3-teal">Requirements</h2>
  <p>A company intends to build a WasteService for the <em>separate collection of waste</em>, composed of a set of elements:</p>
  <ol>
    <li>
      <p>a service area (rectangular, flat) that includes:</p>
      <ul>
        <li>
          <p>an INDOOR port, to enter waste material</p>
        </li>
        <li>
          <p>a PlasticBox container, devoted to store objects made of plastic, upto <strong>MAXPB</strong> kg of material.</p>
        </li>
        <li>
          <p>a GlassBox container, devoted to store objects made of glass, upto <strong>MAXGB</strong> kg of material.</p>
        </li>
      </ul>
      <p>The service area is free from internal obstacles, as shown in the following picture:</p>
      <blockquote>
        <p>
          <a href="https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/_images/WasteServiceRoom.PNG">
            <img src="https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/_images/WasteServiceRoom.PNG" alt="WasteServiceRoom.PNG">
          </a>
        </p>
      </blockquote>
    </li>
    <li>
      <p>a DDR robot working as a transport trolley, that is intially situated in its HOME location. The transport trolley has the form of a square of side length <strong>RD</strong>.</p>
      <p>The transport trolley is used to performa a deposit action that consists in the following phases:</p>
      <ol>
        <li>
          <p>pick up a waste-load from a Waste truck located on the INDOOR</p>
        </li>
        <li>
          <p>go from the INDOOR to the proper waste container</p>
        </li>
        <li>
          <p>deposit the waste-load in the container</p>
        </li>
      </ol>
    </li>
    <li>
      <p>a Service-manager (an human being) which supervises the state of the service-area by using a WasteServiceStatusGUI.</p>
    </li>
    <li>
      <p>a Sonar and a Led connected to a RaspnerryPi. The Led is used as a <em>warning devices</em>, according to the following scheme:</p>
      <ul>
        <li>
          <p>the Led is <strong>off</strong> when the transport trolley is at HOME</p>
        </li>
        <li>
          <p>the Led <strong>blinks</strong> while the transport trolley is moving</p>
        </li>
        <li>
          <p>the Led is <strong>on</strong> when transport trolley is stopped.</p>
        </li>
      </ul>
      <p>The Sonar is used as an ‘alarm device’: when it measures a distance less that a prefixed value <strong>DLIMT</strong>, the transport trolley must be stopped. It will be resumed when Sonar detects again a distance higher than <strong>DLIMT</strong>.</p>
    </li>
  </ol>
  <h3 id="toc_4" class="w3-container w3-green">TFRequirements</h3>
  <p>The main goal of the WasteService software is to allow a Waste truck to deposit its load of <strong>TruckLoad</strong> kg plastic or glass in the proper container.</p>
  <p>The global story can be described as follows:</p>
  <ol>
    <li>
      <p>The Waste truck driver approaches the INDOOR and sends (using a smart device) a request to store the load, by specifyng the type of the material (plastic or glass) and its TruckLoad.</p>
    </li>
    <li>
      <p>The WasteService sends the answer <em>loadaccept</em> if the final content of proper container will not surpass the maximum value allowed (<em>MAXPB</em> or <em>MAXGB</em>). Otherwise, it sends the answer <em>loadrejecetd</em> and the Waste truck leaves the INDOOR area.</p>
    </li>
    <li>
      <p>When the load is accepted, the transport trolley reaches the INDOOR, picks up the material, goes to the proper container and settles the material. During this activity, the WasteService <strong>blinks</strong> the Led</p>
    </li>
    <li>
      <p>When the deposit action is terminated, the transport trolley excutes another deposit command (if any) or returns to its HOME.</p>
    </li>
  </ol>
  <p>The WasteService must create a WasteServiceStatusGUI that shows to the <em>Service-manager</em>:</p>
  <ul>
    <li>
      <p>the current state of the transport trolley and it position in the room</p>
    </li>
    <li>
      <p>the current weigth of the material stored in the two waste-containers</p>
    </li>
    <li>
      <p>the current state of the Led</p>
    </li>
  </ul>
  <h2 id="toc_5" class="w3-container w3-teal">Analisi dei Requisiti</h2>
  <p>Per ogni requisito analizzato in questo SPRINT è stato incluso un modello eseguibile in <a href="../#scelta-del-linguaggio-di-modellazione">Qak</a>.</p>
  <h3 id="toc_6" class="w3-container w3-green">Requisiti e chiarimenti</h3>
  <ul>
    <li>
      <p>
        <strong>request</strong>: il <em>WasteService</em> accetta richieste di deposito da <em>Waste truck</em> che arrivano nella zona specificata come INDOOR, che specificicano il tipo di materiale da depositare</p>
      <ul>
        <li>il sistema può controllare se c'è spazio per un certo materiale: accetta (risposta <em>loadaccept</em>), e rifiuta (risposta <em>loadrejected</em>) le richieste di deposito in caso contrario</li>
      </ul>
      <ol>
        <li>
          <blockquote>
            <p>Domanda: le richieste possono essere gestite anche mentre il robot è in attività?</p>
          </blockquote>
          <p>Sì, potrebbe arrivare altro camion che chiede.</p>
        </li>
        <li>
          <blockquote>
            <p>Domanda: solo un camion alla volta in INDOOR?</p>
          </blockquote>
          <p>Sì.</p>
        </li>
      </ol>
    </li>
    <li>
      <p>
        <strong>deposit</strong>: il <em>trolley</em>, quando viene attivato, raccoglie i materiali a INDOOR, e li deposita, in base al tipo, in GLASS BOX o PLASTIC BOX; questa è una <em>deposit action</em>:</p>
      <ol>
        <li>Raccolta di rifiuti da <em>Waste truck</em> in INDOOR</li>
        <li>Andare da INDOOR a contenitore rifiuti (* BOX)</li>
        <li>Depositare rifiuti nel contenitore</li>
      </ol>
    </li>
    <li>
      <p>
        <strong>indoor-more-requests</strong>: il <em>trolley</em>, terminata una <em>deposit action</em>, torna a HOME solo se non ci sono altre richieste da gestire, sennò gestisce subito la richiesta successiva andando a INDOOR</p>
    </li>
    <li>
      <p>
        <strong>led</strong>: nel sistema è presente un led che:</p>
      <ul>
        <li>è <em>acceso</em> se il <em>trolley</em> è a HOME</li>
        <li>
          <em>lampeggia</em> se il <em>trolley</em> è in attività</li>
        <li>è <em>spento</em> se il trolley è in stato di <em>stop</em>
        </li>
      </ul>
    </li>
    <li>
      <p>
        <strong>sonar-stop</strong>: è presente un <em>sonar</em> che, se misura una distanza sotto DLIMIT (valore prefissato), mette il <em>trolley</em> in stato di <em>stop</em> fino a che la distanza non torna a DLIMIT, nel qual caso il <em>trolley</em> riparte</p>
      <ol>
        <li>
          <blockquote>
            <p>Domanda: cosa vuol dire precisamente <em>stop</em>? Torna a HOME o rimane lì?</p>
          </blockquote>
          <p>Si ferma e basta.</p>
        </li>
      </ol>
    </li>
    <li>
      <p>
        <strong>gui</strong>: è presente una gui (<em>WasteServiceStatusGUI</em>) che mostra i seguenti dati:</p>
      <ul>
        <li>Stato del <em>trolley</em> e sua posizione</li>
      </ul>
      <ol>
        <li>
          <blockquote>
            <p>Domanda: Posizione del trolley: deve essere precisa o informazione più generale (INDOOR, in mezzo, HOME, ecc)?</p>
          </blockquote>
          <p>Basta una posizione più generale.</p>
        </li>
      </ol>
      <ul>
        <li>Carico depositato attuale (in kg)</li>
        <li>Stato del Led (acceso/spento/lampeggiante)</li>
      </ul>
    </li>
  </ul>
  <p>Da questa analisi, emerge che il <em>core business</em> del sistema è costituito dai requisiti di <strong>request</strong>, <strong>deposit</strong>, e <strong>indoor-more-requests</strong>. Un primo sprint SCRUM sarà quindi lo sviluppo a partire da questi requisiti centrali, mentre i successivi sprint implementeranno le funzionalità aggiuntive di <strong>led</strong>, <strong>sonar-stop</strong>, e <strong>gui</strong>.</p>
  <h3 id="toc_7" class="w3-container w3-green">Glossario</h3>
  <ul>
    <li>
      <p>
        <em>WasteService</em>: il servizio centrale che risponde alle richieste dei <em>waste truck</em>
      </p>
    </li>
    <li>
      <p>
        <em>Waste truck</em>: i camion che arrivano dall'esterno a depositare rifiuti</p>
    </li>
    <li>
      <p>Area di servizio: <strong>INDOOR</strong>, <strong>PlasticBox</strong>, <strong>GlassBox</strong>, aree definite nella creazione del sistema e punti di riferimento per il <em>trolley</em>. In particolare:</p>
      <ul>
        <li>INDOOR: area dove i <em>waste truck</em> si fermano a lasciare il proprio carico, facendo una richiesta di deposito. Essa può contenere un <em>waste truck</em> alla volta</li>
        <li>PlasticBox: area dove depositare la plastica</li>
        <li>GlassBox: area dove depositare il vetro</li>
      </ul>
    </li>
    <li>
      <p>
        <em>transport trolley</em> (o <em>trolley</em>): robot DDR (differential drive robot), di dimensione approssimabile a quadrato di lato RD, usato per trasportare i rifiuti nel sistema</p>
    </li>
    <li>
      <p>
        <em>Service-manager</em>: umano che supervisiona il sistema tramite la <em>WasteServiceStatusGUI</em>
      </p>
    </li>
    <li>
      <p>
        <em>Sonar</em>: sensore che misura distanza</p>
    </li>
    <li>
      <p>
        <em>Led</em>: spia luminosa</p>
    </li>
  </ul>
  <h3 id="toc_8" class="w3-container w3-green">Analisi dei requisiti</h3>
  <p>Guardando i requisiti definiti dal committente si possono fare delle prime analisi sul da farsi.</p>
  <h4 id="toc_9">Analisi <strong>request</strong>
  </h4>
  <p>Si tratta di una domanda con risposta, quindi l'implementazione immediata è request-reply:</p>
  <pre>
    <div class="w3-code">Request loadDeposit : loadDeposit(MAT, QNT)
Reply loadaccept : loadaccept()
Reply loadrejected : loadrejected()
</div>
  </pre>
  <p>
    <img src="../img/req_request.png" alt="schema request">
  </p>
  <p>Il WasteService deve di conseguenza essere un attore, in grado di ricevere richieste e inviare risposte, e anche inviare messaggi a sua volta alle altre componenti del sistema.</p>
  <pre>
    <div class="w3-code">Context ctxwasteservice ip [host="localhost" port=8050]

QActor wasteservice context ctxwasteservice {...}
</div>
  </pre>
  <p>
    <a href="../../model.requisiti/src/request.qak">Modello eseguibile Request</a>
  </p>
  <p>Viene definito un primo test plan, eseguibile con le classi generate dal modello eseguibile:</p>
  <p>
    <a href="../../model.requisiti/test/it/unibo/TestRequest.java">Test plan Request</a>
  </p>
  <h4 id="toc_10">Analisi <strong>deposit</strong>
  </h4>
  <p>È presente nel sistema un <em>trolley</em>; visto che necessita di trovarsi in un altro nodo rispetto al WasteService, e di comunicare con esso, viene modellato come un attore: <em>Trolley</em>.</p>
  <p>Esso, da requisiti, usa un robot DDR che <em>lavora come trolley</em>. Sono già fornite componenti software che implementano il controllo di un robot DDR tramite operazioni primitive (vedi <a href="../#materiale-fornito-dal-committente">Materiale fornito dal committente</a>), cioè BasicRobot22. Quindi, il Trolley dovrà interagire con BasicRobot22 tramite i comandi primitivi di quest'ultimo, per controllare il robot DDR.</p>
  <p>L'interazione tra <em>Trolley</em> e <em>WasteService</em> riguardante l'innesco e lo svolgimento di una <em>deposit action</em> lascia invece aperte diverse opzioni, che sono discusse successivamente in fase di analisi del problema.</p>
  <p>La struttura dell'operazione è descritta nel modello eseguibile seguente:</p>
  <p>
    <a href="../../model.requisiti/src/deposit.qak">Modello eseguibile Deposit</a>
  </p>
  <p>Viene definito un primo test plan, eseguibile con le classi generate dal modello eseguibile:</p>
  <p>
    <a href="../../model.requisiti/test/it/unibo/TestDeposit.java">Test plan Deposit</a>
  </p>
  <h4 id="toc_11">Analisi <strong>indoor-more-requests</strong>
  </h4>
  <p>Dal requisito in sè non è possibile formalizzare con più precisione l'interazione precisa interna al sistema che lo adempie, rimanendo punti aperti diversi elementi fondamentali (i tipi di interazione tra componenti del sistema). Viene definito un test plan primitivo in seguito:</p>
  <p>
    <a href="../../model.requisiti/test-disabled/TestIndoorMoreRequests.java">Test plan Indoor-More-Requests</a>
  </p>
  <h4 id="toc_12">Materiale fornito dal committente</h4>
  <ul>
    <li>Robot DDR: viene fornita una componente software, <em>BasicRobot22</em>, che implementa comandi primitivi <em>MOVE = w | s | l | r | h</em>, e permette di fare <em>step</em> in avanti per un certo tempo.</li>
    <li>Sonar: viene fornito un programma in C, <em>SonarAlone.c</em>, che stampa su standard output la distanza attualmente rilevata dal sonar, configurando le porte GPIO in questo modo:<ul>
        <li>Porta VCC : pin fisico 4 (+5v)</li>
        <li>Porta GND : pin fisico 6 (GND)</li>
        <li>Porta TRIG: pin fisico 11 (WPI 0, BCM 17)</li>
        <li>Porta ECHO: pin fisico 13 (WPI 2, BCM 27)</li>
      </ul>
    </li>
    <li>Led: vengono forniti gli script bash e <em>led25GpioTurnOn.sh</em> e <em>led25GpioTurnOff.sh</em> per accendere e spegnere un Led connesso alla porta GPIO 25 di un Raspberry Pi.</li>
  </ul>
  <h3 id="toc_13" class="w3-container w3-green">Scelta del linguaggio di modellazione</h3>
  <p>Nelle varie fasi di analisi di questo progetto abbiamo usato come linguaggio di modellazione il linguaggio ad attori Qak, essendo il sistema da realizzare un sistema distribuito, quindi adatto ad essere rappresentato tramite attori.</p>
  <h2 id="toc_14" class="w3-container w3-teal">Analisi del problema</h2>
  <h3 id="toc_15" class="w3-container w3-green">Componenti</h3>
  <p>Data la numerosa quantità di componenti che comunicano tra loro, implementare la logica del sistema come un insieme di attori è abbastanza naturale.</p>
  <h4 id="toc_16">Requisito <strong>request</strong> - componenti</h4>
  <p>Il WasteService è rappresentato come già detto in analisi dei requisiti da un attore.</p>
  <p>Inoltre, per poter interagire con i cassonetti, sono introdotti degli attori di Storage per comunicare modifiche allo storage e inviare aggiornamenti a componenti di controllo per futuri Sprint.</p>
  <p>Anche qua due opzioni possibili:</p>
  <ul>
    <li>
      <p>
        <em>Storage manager centrale</em>: un solo attore che gestisce tutti i cassonetti, tenendo traccia dei contenuti attuali e facendo da unico fronte di comunicazione nel sistema per questi dati. Questo semplificherebbe la comunicazione non richiedendo di distinguere il destinatario in base al materiale, ma richiedendo forse più complessità nel caso, per esempio, in cui i dati di storage siano ricavati da sensori su ogni cassonetto, che quindi dovrebbero aggiornare separatamente lo stesso controllore contenente lo StorageManager.</p>
      <pre>
        <div class="w3-code">QActor storage context ctxwasteservice {...}
</div>
      </pre>
      <p>
        <img src="../img/arch_request_1.png" alt="">
      </p>
    </li>
    <li>
      <p>
        <em>Storage manager separati</em>: un attore per cassonetto (rappresentato nell'esempio sopra), che andrà quindi separatamente interpellato in base al tipo di materiale. La soluzione sarebbe la più intuitiva ma con i problemi sopraelencati.</p>
      <pre>
        <div class="w3-code">QActor storage_glass context ctxwasteservice {...}
QActor storage_paper context ctxwasteservice {...}
</div>
      </pre>
      <p>
        <img src="../img/arch_request_2.png" alt="">
      </p>
    </li>
  </ul>
  <p>
    <strong>Conclusione.</strong> Si è ritenuta migliore la prima opzione, cioè <strong>usare un solo componente StorageManager</strong>, rendendo più semplice la pianificazione e la progettazione del sistema, a livello di architettura e interazione, oltre a rendere più facile l'espansione (per esempio, aggiungendo altri tipi di cassonetto) tramite configurazione interna al componente, che nel secondo caso richiederebbe la creazione di nuovi componenti.</p>
  <p>
    <img src="../img/arch_request_1.png" alt="">
  </p>
  <h3 id="toc_17" class="w3-container w3-green">Requisito <strong>deposit</strong> - La deposit action</h3>
  <h4 id="toc_18">Posizione delle aree di interesse</h4>
  <p>Da requisiti, si suppone che le posizioni e grandezza delle aree di HOME, INDOOR, e cassonetti vari, siano decise a priori e a priori comunicate al trolley prima dell'inizio del movimento. Riguardo a come questo sia deciso si consulti <a href="../#configurazione">Configurazione</a>.</p>
  <h4 id="toc_19">Pathfinding</h4>
  <p>Data una posizione di partenza e di arrivo verso la quale il trolley deve navigare, questo può calcolare due tipi di percorso:</p>
  <ol>
    <li>
      <p>Dividendo la stanza in una griglia quadrata di lato RD, il trolley può semplicemente navigare lungo le direzioni cartesiane, prima ad una coordinata della destinazione e poi all'altra.</p>
      <p>
        <img src="../img/navigazione_cart.jpg" alt="">
      </p>
      <p>
        <strong>PRO</strong>: si dispone già di componenti in grado di generare e seguire percorsi su griglia in direzioni cartesiane, l'implementazione sarebbe quindi semplice</p>
      <p>
        <strong>CONTRO</strong>: più lento dell'alternativa.</p>
    </li>
    <li>
      <p>Il trolley compie un percorso diretto a destinazione ignorando la griglia.</p>
      <p>
        <img src="../img/navigazione_diretta.jpg" alt="">
      </p>
      <p>
        <strong>PRO</strong>: il percorso sarebbe diretto e più veloce.</p>
      <p>
        <strong>CONTRO</strong>: non disponendo di componenti già implementate per questo scopo, andrebbe programmata la logica di pathfinding e navigazione per questa casistica.</p>
    </li>
  </ol>
  <p>
    <strong>Conclusione.</strong> Data la scala ridotta del problema, e la scarsa urgenza di esso, si ritiene migliore la prima opzione, la <strong>navigazione cartesiana</strong>, che permette di riutilizzare i componenti di navigazione di robot già a disposizione ottimizzando i tempi di sviluppo.</p>
  <h4 id="toc_20">Gestione della deposit action</h4>
  <p>Esistono più opzioni per quanto riguarda quale componente
debba gestire la deposit action:</p>
  <ol>
    <li>
      <p>Trolley potrebbe svolgere internamente la gestione dei vari passaggi, ricevendo da WasteService solo le istruzioni per iniziare una deposit action. Questo richiederebbe di spostare la logica di business dentro al Trolley, in parte.</p>
    </li>
    <li>
      <p>Il Trolley potrebbe essere un puro attuatore, offrendo un' "interfaccia" di operazioni primitive, cioè <em>spostarsi verso delle coordinate</em>, <em>caricare i rifiuti</em> (da WasteTruck) e <em>scaricare i rifiuti</em> (nel cassonetto). Il WasteService si occuperebbe di gestire la successione dei passaggi di una deposit action, mentre il Trolley necessiterebbe solo di gestire la sequenza delle operazioni primitive del BasicRobot per raggiungere le posizioni, non conoscendo logica di business.</p>
    </li>
  </ol>
  <p>
    <strong>Conclusione.</strong>  Per avere una migliore gestione dei dati, e non dividere troppo la logica di business tra nodi diversi, abbiamo deciso per la seconda opzione, <strong>trattare il Trolley come attuatore e lasciare a WasteService la gestione dell'azione di deposito</strong>. Questo porta a una semplificazione della struttura interna del Trolley, ma al contempo ad una complicazione di WasteService, che deve contemporaneamente gestire richieste e risposte con WasteTruck, e i passaggi della deposit action.</p>
  <p>Per una formalizzazione degli stati, si consulti <a href="../#architettura-logica">Architettura Logica</a>.</p>
  <p>Inoltre, questa modalità permette di assolvere il requisito <strong>indoor-more-requests</strong> senza richiedere interazioni apposite tra WasteService e Trolley in caso di nuove richieste durante l'operazione precedente; nel primo caso, sarebbe stato necessario far conoscere al Trolley l'arrivo di richieste per permettere di sapere se tornare o meno ad HOME.</p>
  <p>Per poter verificare i requisiti, è necessario poter conoscere la posizione del Trolley, in termini di quale luogo di interesse è stato raggiunto. Visto che con questa modalità Trolley non conosce le posizioni delle vare aree di interesse (dato che riceve direttamente comandi per spostarsi a una certa coordinata), è necessario che comunichi a WasteService la sua posizione numerica. Per farlo, in maniera coerente con il metodo di navigazione scelto si divide la stanza in una griglia, con caselle quadrate di lato RD (grandezza del trolley, da requisiti). Le coordinate dei luoghi d'interesse sono così indicate:</p>
  <ul>
    <li>(0,0) è la casella in alto a sinistra della stanza.</li>
    <li>(X, Y) è la casella X caselle a destra, e Y caselle in basso, rispetto a (0,0)</li>
    <li>Un luogo d'interesse copre una o più caselle, ed è delimitato indicando casella in alto a sinistra e casella in basso a destra.</li>
  </ul>
  <h4 id="toc_21">Idee per possibile ottimizzazione</h4>
  <p>Si è notato infine che, data la staticità dell'ambiente, i percorsi in caso di funzionamento regolare hanno un numero ridotto, essendo sempre tra le stesse (e poche) posizioni. Quindi, se necessario, potrebbe essere possibile precalcolare i percorsi, e riutilizzare sempre gli stessi senza richiedere la generazione ogni volta; nel caso per qualche motivo il trolley si ritrovi in una posizione fuori dalle aspettative, il percorso andrebbe comunque calcolato ad hoc.</p>
  <h3 id="toc_22" class="w3-container w3-green">Configurazione</h3>
  <p>Da requisiti, diversi valori, cioè</p>
  <ul>
    <li>
      <em>DLIMIT</em>
    </li>
    <li>La posizione di HOME</li>
    <li>La posizione e area di INDOOR</li>
    <li>La posizione e area di GLASS BOX e PLASTIC BOX</li>
  </ul>
  <p>sono impostati a priori. Questo può essere realizzato cablando i valori nel codice, ma l'opzione più sensata è quella di usare dei file di configurazione, modificabili dall'utente.</p>
  <p>In questo SPRINT, considerando solo il core business dell'applicazione, l'unico componente che necessita di conoscere i dati di configurazione è WasteService. Quindi, il file di configurazione sarà collocato all'interno del suo nodo.</p>
  <p>Un esempio:</p>
  <p>
    <em>WasteService.json</em>
  </p>
  <pre>
    <div class="w3-code">{
    "positions": {
        "HOME": [[0,0], [0,0]],
        "INDOOR" : [[0,15], [3,15]],
        "GLASS_BOX" : [[13,0], [14,0]],
        "PLASTIC_BOX": [[16,4], [16,5]]
    },
    "DLIMIT": 50
}
</div>
  </pre>
  <h3 id="toc_23" class="w3-container w3-green">Interazione</h3>
  <h4 id="toc_24">Requisito <strong>request</strong>
  </h4>
  <p>È necessario che (in caso di loadaccept) il waste truck sappia quando lo scarico dei rifiuti da parte del trolley è stato completato per poter ripartire. Ci sono diverse opzioni:</p>
  <ol>
    <li>
      <p>La risposta (loadaccept) potrebbe essere semplicemente inviata solo a scarico completato, a differenza di loadrejected che verrebbe inviata appena possibile. Una volta arrivata la risposta, il camion potrebbe partire. La conseguenza di questo approccio sarebbe l'impossibilità di rilevare errori da parte del Waste truck: "vedrebbe" nella UI un'attesa senza sapere se è per via dello scarico rifiuti in corso oppure per un errore.</p>
    </li>
    <li>
      <p>La risposta (loadaccept) arriva subito come per loadrejected, per informare il Waste truck il prima possibile, e viene inviato un successivo messaggio pickedUp per notificare l'avvenuto scarico e la possibilità di partire. Questo richiede che il Waste truck sia anche in grado di ricevere passivamente messaggi, e non solo inviare richieste e ricevere risposte come da requisiti; è possibile, ma richiede accorgimenti più specifici nello sviluppo.</p>
      <pre>
        <div class="w3-code">Dispatch pickedUp : pickedUp()
</div>
      </pre>
    </li>
  </ol>
  <p>
    <strong>Conclusione.</strong> Si ritiene migliore la seconda opzione, <strong>la partenza del camion dopo un dispatch pickedUp</strong>: il vantaggio dal punto di vista dell'utente (non necessariamente competente nella tecnologia) nel sapere subito se è stato accettato o meno il carico, e non rimanere bloccati in una schermata di attesa o equivalente anche in caso di successo, vale la pena di avere ulteriori accortezze in implementazione.</p>
  <p>Inoltre, WasteService deve poter sapere da StorageManager lo stato attuale di riempimento dei cassonetti.</p>
  <ol>
    <li>
      <p>Questo potrebbe essere implementato come una request-reply, chiedendo a StorageManager lo stato dei cassonetti.</p>
      <pre>
        <div class="w3-code">Request storageAsk : storageAsk(MAT)
Reply storageAt : storageAt(MAT, QNT)
</div>
      </pre>
    </li>
    <li>
      <p>Potrebbe essere implementato come un evento inviato da StorageManager a ogni modifica dei contenuti, o in modo simile rendendo i cassonetti risorse osservabili.</p>
      <pre>
        <div class="w3-code">Event storageUpdate : storageUpdate(MAT, QNT)
</div>
      </pre>
    </li>
  </ol>
  <p>
    <strong>Conclusione.</strong> Per adempiere a questo requisito si è ritenuta migliore la prima opzione, <strong>request-reply</strong>; nel secondo caso, WasteService dovrebbe salvare in una variabile interna di stato il dato aggiornato ogni volta che lo riceve, cosa che potrebbe avvenire in qualunque momento, invece di chiederlo semplicemente all'occorrenza.</p>
  <p>
    <img src="../img/an_int_request.png" alt="modello request">
  </p>
  <p>
    <a href="../../model.problema/src/pro_request.qak">Modello eseguibile di Request dopo queste considerazioni</a>
  </p>
  <h4 id="toc_25">Requisito <strong>deposit</strong>
  </h4>
  <p>Il Wasteservice, come specificato in <a href="../#gestione-della-deposit-action">Gestione della deposit action</a>, si occupa dei vari passaggi del deposito. Deve quindi poter inviare messaggi a Trolley per coordinare questa operazione. Deve inoltre sapere quando Trolley termina le operazioni per iniziare le successive.</p>
  <ol>
    <li>Questo potrebbe essere implementato come una serie di dispatch, con un singolo dispatch per le conferme di operazione conclusa.<pre>
        <div class="w3-code">Dispatch trolleyMove : trolleyMove(X, Y)
Dispatch trolleyCollect : trolleyCollect(MAT, QNT)
Dispatch trolleyDeposit : trolleyDeposit()
Dispatch trolleyDone : trolleyDone(OK)
</div>
      </pre>
    </li>
    <li>Oppure, in alternativa, come diverse richieste, a cui Trolley risponde a operazione conclusa:<pre>
        <div class="w3-code">Request trolleyMove : trolleyMove(X, Y)
Request trolleyCollect : trolleyCollect(MAT, QNT)
Request trolleyDeposit : trolleyDeposit()
Reply trolleyDone : trolleyDone(OK)
</div>
      </pre>
    </li>
  </ol>
  <p>
    <strong>Conclusione.</strong> Si sceglie la seconda opzione, modellare le operazioni primitive come <strong>request-response</strong>, perchè permette a Trolley di non conoscere WasteService ma di agire solo in risposta a delle richieste.</p>
  <p>Inoltre, per iniziare lo scarico nel cassonetto viene comunicato il deposito di un materiale da parte del trolley:</p>
  <pre>
    <div class="w3-code">Dispatch storageDeposit : storageDeposit(MAT, QNT)
</div>
  </pre>
  <p>Questo messaggio viene inviato da Trolley a StorageManager, ed è necessario per trattare allo stesso modo la situazione di test virtuale e il caso reale; infatti, un caso reale potrebbe usare un sensore nei cassonetti per aggiornare i dati sui contenuti noti a StorageManager, mentre in una situazione virtuale questo deve essere necessariamente aggiornato tramite messaggi.</p>
  <p>In un caso reale, bisogna quindi testare la consistenza tra dati noti a StorageManager dopo l'invio del messaggio, e i dati reali dei contenuti. Un test plan per questo caso è il seguente:</p>
  <p>
    <a href="../../wasteservice.prototype/test/it/unibo/TestDepositReal.java.disabled">Test plan per confronto dati veri e gestiti</a>
  </p>
  <p>Il modello per le componenti correlate a deposit è il seguente:</p>
  <p>
    <img src="../img/an_int_deposit.png" alt="modello deposit">
  </p>
  <p>
    <a href="../../model.problema/src/pro_deposit.qak">Modello eseguibile di Deposit e Indoor-more-requests dopo queste considerazioni</a>
  </p>
  <h3 id="toc_26" class="w3-container w3-green">Architettura Logica</h3>
  <p>Ecco quindi l'architettura logica finale del sistema in generale per questo SPRINT:</p>
  <p>
    <img src="../img/arch_logica.png" alt="modello architettura logica">
  </p>
  <p>
    <img src="../img/arch_fsm_wasteservice.png" alt="diagramma stati WasteService">
  </p>
  <p>
    <a href="../../wasteservice.prototype/src/prototype_sprint1.qak">
      <strong>Prototipo eseguibile</strong>
    </a>
  </p>
  <p>Per scopo di prototipo e simulazione, i Waste truck vengono trattati come attori, ma nel caso reale sarebbero "alieni" al sistema, inviando dati dall'esterno, probabilmente tramite una GUI (web o analoga) usabile dal camionista. Essi, come specificato in <a href="../#requisito-request">Interazione: request</a>, devono comunque disporre di una componente software in grado di rimanere in ascolto di messaggi, oltre che inviare richieste.</p>
  <h3 id="toc_27" class="w3-container w3-green">Test Plan</h3>
  <p>Vengono aggiornati i test plan introdotti in analisi dei requisiti, e introdotti di nuovi per collaudare alcuni elementi emersi in questa fase. Tutti i test sul prototipo sono fatti presupponendo l'assenza di un wastetruck che invii indipendentemente richieste che interferirebbero con il test.</p>
  <p>Per lo scopo di eseguire il modello Qak senza wastetruck, viene incluso un file pl differente a quello generato che non include il wastetruck tra gli attori: <a href="../../wasteservice.prototype/wasteservice_proto_sprint1_test.pl">wasteservice_proto_sprint1_test.pl</a>, con un <a href="../../wasteservice.prototype/test/it/unibo/RunPrototypeNoTruck_Sprint1.kt">file Kotlin</a> apposito per usarlo.</p>
  <h4 id="toc_28">TestPlan: request</h4>
  <p>Test plan in Java: <a href="../../wasteservice.prototype/test/it/unibo/TestRequest.java">TestRequest.java</a>
  </p>
  <ul>
    <li>
      <p>
        <strong>Test Deny</strong>: si invia una richiesta di loadDeposit al WasteService per una quantità maggiore di quella che i cassonetti possono ospitare e si verifica che risponda con un <em>loadrejected</em>.</p>
    </li>
    <li>
      <p>
        <strong>Test Accept</strong>: si invia una richiesta di loadDeposit al WasteServicee si verifica che risponda con loadrejected.</p>
    </li>
    <li>
      <p>
        <strong>Test PickedUp</strong>: si invia una richiesta di loadDeposit al WasteService, usando un finto attore di nome wastetruck</p>
    </li>
  </ul>
  <h4 id="toc_29">TestPlan: deposit</h4>
  <p>Test plan in Java: <a href="../../wasteservice.prototype/test/it/unibo/TestDeposit.java">TestDeposit.java</a>
  </p>
  <ul>
    <li>
      <p>
        <strong>Test TrolleyCollect</strong>: Invia richiesta trolleyCollect con quantità N e materiale M. Verifica che dopo la richiesta Trolley contenga i materiali corrispondenti.</p>
    </li>
    <li>
      <p>
        <strong>Test TrolleyDeposit</strong>: Invia richiesta trolleyDeposit con Trolley già contenente materiale M in quantità M. Verifica che dopo la richiesta Trolley non contenga più materiali, e StorageManager contenga i materiali nelle quantità indicate.</p>
    </li>
    <li>
      <p>
        <strong>Test TrolleyMove</strong>: Invia richiesta trolleyMove con coordinate X e Y. Si verifichi tramite Coap che a fine operazione Trolley si trovi alla posizione corrispondente.</p>
    </li>
    <li>
      <p>
        <strong>Test Positions Glass</strong>: Invia richiesta di deposito con vetro. Verifica che partendo da HOME, le posizioni attraversate siano HOME, INDOOR, e GLASS_BOX.</p>
    </li>
    <li>
      <p>
        <strong>Test Positions Plastic</strong>: Invia richiesta di deposito con plastica. Verifica che partendo da HOME, le posizioni attraversate siano HOME, INDOOR, e PLASTIC_BOX.</p>
    </li>
    <li>
      <p>
        <strong>Test Deposit</strong>: Invia richiesta di deposito con quantità N. Verifica che StorageManager finisca con quantità aumentata di N a deposit action terminata.</p>
    </li>
  </ul>
  <h4 id="toc_30">TestPlan: indoor-more-requests</h4>
  <p>Test plan in Java: <a href="../../wasteservice.prototype/test/it/unibo/TestMoreRequests.java">TestMoreRequests.java</a>.</p>
  <ul>
    <li>
      <p>
        <strong>Test GoHome</strong>: Con Trolley a GLASS_BOX, verifica che in assenza di nuove richieste torni a HOME.</p>
    </li>
    <li>
      <p>
        <strong>Test TrolleyMove</strong>: Con Trolley a GLASS_BOX, verifica che in presenza di nuove richieste torni a INDOOR.</p>
    </li>
  </ul>
  <h2 id="toc_31" class="w3-container w3-teal">Progettazione</h2>
  <p>La progettazione e lo sviluppo delle componenti software stabilite in fase di analisi è stata divisa in questo modo:</p>
  <ul>
    <li>Trolley, e interazione con BasicRobot: L. Guerra</li>
    <li>Wasteservice (parte relativa a interazione e controllo Trolley): L. Guerra</li>
    <li>Wasteservice (parte relativa a gestione richieste Wastetruck): F. Lenzi</li>
    <li>StorageManager: F. Lenzi</li>
    <li>WasteTruck (ricezione pickUp e GUI): F. Lenzi</li>
  </ul>
  <p>È stato possibile dividere facilmente lo sviluppo di WasteService per la struttura che è stata adottata, dettagliata <a href="../#wasteservice">in seguito</a>.</p>
  <h3 id="toc_32" class="w3-container w3-green">In generale</h3>
  <p>In fase di progettazione e sviluppo, i vari attori facenti parti del sistema sono stati strutturati come risorsa osservabile COaP, con dati in formato Prolog, sfruttando la libreria QakActor, sia per facilitare l'espansione futura in successivi SPRINT, sia per rendere più facile il testing.</p>
  <p>Per esempio Trolley, quando osservato, fornisce questi dati in formato Prolog:</p>
  <pre>
    <div class="w3-code">state(work)
pos(X,Y)
{content(MAT,QNT)}
</div>
  </pre>
  <p>con <code>content</code> opzionale se non trasporta carichi.</p>
  <p>Inoltre, ad ogni attore Qak è stat associata una classe Kotlin di support, per ridurre il codice nel file Qak e permettere comportamenti di classe più complessi. Ogni classe implementa un'interfaccia che contiene le proprietà e metodi accessibili dall'attore.</p>
  <h3 id="toc_33" class="w3-container w3-green">Struttura del software</h3>
  <p>Il sistema è stato realizzato in linguaggio Kotlin, e parti minori in Java, ed è stato diviso in più progetti:</p>
  <ul>
    <li>
      <em>wasteservice.shared</em>: contiene la classe di configurazione <code>SystemConfig</code>, enumerativi, e utilità comuni alle varie parti del sistema.</li>
    <li>
      <em>wasteservice.core</em>: contiene il core business dell'applicazione, vale a dire WasteService, Trolley, e StorageManager, che è stato implementato in questo SPRINT.</li>
  </ul>
  <p>Il software è contenuto nel package <em>it.unibo.lenziguerra.wasteservice</em>, eccetto le classi Kotlin generate da Qak che sono nel percorso attribuito da quel sistema. In particolare i due progetti contengono questi package:</p>
  <ul>
    <li>
      <strong>wasteservice.shared</strong>
      <ul>
        <li>
          <em>it.unibo.lenziguerra.wasteservice</em> (config e enumerativi)</li>
        <li>
          <em>it.unibo.lenziguerra.wasteservice.utils</em>
        </li>
      </ul>
    </li>
    <li>
      <strong>wasteservice.core</strong>
      <ul>
        <li>
          <em>it.unibo.lenziguerra.wasteservice.wasteservice</em>
        </li>
        <li>
          <em>it.unibo.lenziguerra.wasteservice.trolley</em>
        </li>
        <li>
          <em>it.unibo.lenziguerra.wasteservice.storage</em>
        </li>
        <li>
          <em>
            <code>wasteservice.qak</code>
          </em>
        </li>
      </ul>
    </li>
  </ul>
  <p>Per scopo di documentazione, il codice allo stato della fine dello SPRINT 1 è stato copiato in una cartella <em>src-sprint1</em>.</p>
  <h3 id="toc_34" class="w3-container w3-green">Test</h3>
  <p>I test plan stabiliti in analisi sono stati adattati al sistema finale dello SPRINT 1, sono eseguibili in questi file:</p>
  <ul>
    <li>
      <a href="../../wasteservice.core/test-sprint1/it/unibo/lenziguerra/wasteservice/wasteservice/TestRequest.java">TestRequest.java</a>
    </li>
    <li>
      <a href="../../wasteservice.core/test-sprint1/it/unibo/lenziguerra/wasteservice/TestDeposit.java">TestDeposit.java</a>
    </li>
    <li>
      <a href="../../wasteservice.core/test-sprint1/it/unibo/lenziguerra/wasteservice/TestMoreRequests.java">TestMoreRequests.java</a>
    </li>
  </ul>
  <p>Note sull'esecuzione:</p>
  <ul>
    <li>È necessario avviare BasicRobot22 prima di eseguire i test, è incluso un <a href="../../wasteservice.core/basicrobot22.yaml">file docker</a> per farlo facilmente, con le impostazioni della mappa che seguono il dominio del problema.</li>
    <li>I test vanno avviati un metodo alla volta, ed è necessario aggiornare la pagina di VirtualEnv di BasicRobot tra le esecuzioni, a causa di requisiti di VirtualEnv e Qak.</li>
  </ul>
  <h3 id="toc_35" class="w3-container w3-green">WasteService</h3>
  <h4 id="toc_36">Divisione</h4>
  <p>È stata presa la decisione di implementare WasteService come due entità software distinte ma interagenti nello stesso nodo:</p>
  <ul>
    <li>
      <em>WasteServiceServer</em>, un applicazione web realizzata con il framework SpringBoot che espone un interfaccia per i WasteTruck, e gestisce le loro richieste e le relative autorizzazioni.</li>
    <li>
      <em>WasteService</em> propter, un attore Qak con annessa classe di supporto, che si occupa di gestire l'operazione di deposito coordinando il Trolley che agisce da attuatore come da analisi.</li>
  </ul>
  <p>Questo permette di realizzare facilmente l'interazione e l'interfaccia per il WasteTruck, oltre ad avere il vantaggio di disaccoppiare l'operazione di deposito dalla gestione delle richieste: il modello degli stati sviluppato in analisi portava a rispondere a una richiesta arrivata da un WasteTruck solo alla fine di una operazione di deposito. In questo modo, invece, il server è sempre in ascolto di richieste, e in grado di gestirle.</p>
  <p>Questo ha inoltre, come effetto secondario, permesso agli sviluppatori di lavorare separatamente alle due parti del progetto (gestione richieste e operazione di deposito)</p>
  <h4 id="toc_37">Richieste</h4>
  <p>La parte di WasteService che da analisi interagisce con WasteTruck viene implementata come server web: la pagina servita fa le veci dell'attore nel modello di analisi WasteTruck.</p>
  <p>Questa pagina contiene script che comunicano con il server di WasteService tramite WebSocket, permettendo sia di inviare richieste e ricevere risposte, sia di ascoltare sulla connessione per la notifica di carico raccolto. WasteTruck diventa quindi, da attore, una pagina web, che viene aperta dal pilota del Waste Truck.</p>
  <p>Tramite WebSocket, la pagina del WasteTruck è in grado di rimanere in ascolto per aggiornamenti sulla raccolta del carico, come da analisi (dispatch <code>pickedUp</code>).</p>
  <p>Il server, per gestire le richieste, deve chiedere come da analisi informazioni a StorageManager: per farlo agisce da "alieno" al contesto Qak, stabilendo una connessione TCP con il contesto di StorageManager (in questa prima versione, ospitato per demo nello stesso nodo). Chiede al Trolley tramite COaP dati sul suo contenuto attuale, per lo stesso motivo.</p>
  <p>L'inizio dell'operazione di deposito viene fatto inviando da "alieno" una richiesta tramite TCP al contesto di WasteService attore ospitato in locale: viene introdotta una nuova richiesta per coordinare le due "metà" di WasteService:</p>
  <pre>
    <div class="w3-code">Request triggerDeposit : triggerDeposit(MAT,QNT)
Reply trolleyPickedUp : trolleyPickedUp(_)
</div>
  </pre>
  <p>WasteServiceServer invia <code>triggerDeposit</code> all'attore per avviare l'operazione di deposito, e riceve <code>trolleyPickedUp</code> per sapere quando inviare <code>pickedUp</code> al WasteTruck come da analisi.</p>
  <h4 id="toc_38">Deposit</h4>
  <p>WasteService attore è simile al modello dell'analisi. È in grado di stabilire la coordinata più vicina al trolley tra quelle incluse nel rettangolo della area di destinazione, e coordina il Trolley attraverso le varie fasi della <em>deposit action</em>.</p>
  <p>Il requisito <strong>indoor-more-requests</strong> è adempiuto in modo semplice: WasteService attore, per comportamento default di Qak, mette in coda eventuali richieste di <code>triggerDeposit</code> arrivate durante una <em>deposit action</em>, e decide se mandare a HOME o a INDOOR il Trolley a operazione finita in base alla presenza o meno di ulteriori richieste in coda.</p>
  <p>L'attore, come detto, è osservabile tramite COaP: la risorsa espone questi dati:</p>
  <pre>
    <div class="w3-code">tpos(LOC) // Posizione del trolley in termini di nome ("home", "indoor", ecc.)
{error(ERR)} // Errore (opz.), nel caso il sistema abbia errori
</div>
  </pre>
  <h4 id="toc_39">Gestione errori</h4>
  <p>In caso di errori, cioè, allo stato virtuale del sistema,collisione del Trolley, il sistema si blocca e necessita di una risoluzione manuale del problema seguita da un riavvio. Questo comportamento è stato deciso data l'impossibilità di risolvere dal lato del sistema problemi di questa natura, che in un caso reale sarebbero dati da incidenti fisici nell'area risolvibili solo da un operatore.</p>
  <p>
    <img src="../img/prog1_wasteservice_arch.jpg" alt="architettura di WasteService">
  </p>
  <p>
    <img src="../img/prog1_wasteservice_inter.jpg" alt="interazioni WasteService">
  </p>
  <p>
    <em>Diagramma sintetico delle interazioni di WasteService in caso di richiesta, a scopo esplicativo</em>
  </p>
  <h3 id="toc_40" class="w3-container w3-green">Trolley</h3>
  <p>Per lo spostamento del Trolley, come da analisi, si è pensato di utilizzare il componente software <em>BasicRobot</em>. In particolare, il Trolley interagisce con l'attore <em>pathexec</em>, che permette di svolgere percorsi costituiti da una serie di comandi (w: forward, r: gira a destra, l: gira a sinistra) con una singola interazione request-reply.</p>
  <p>Il Trolley agisce, come da analisi, come semplice attuatore. Espone come "interfaccia" la possibilità di inviare richieste <code>trolleyDeposit</code>, <code>trolleyCollect</code>, e <code>trolleyMove</code>. Le risposte inviate dal robot sono state espanse da una singola risposta <code>trolleyDone(OK)</code> da analisi, a due risposte <code>trolleyDone</code> e <code>trolleyFail(REASON)</code>, per rendere più semplice la distinzione dei casi in Qak.</p>
  <p>Le prime due richieste sono interamente gestite dalla classe di supporto legata al trolley, <em>ITrolleySupport</em>; al momento è implementata per il caso virtuale, ma è facilmente espandibile per un eventuale caso reale.</p>
  <p>L'operazione di movimento è come sopra gestita da <em>pathexec</em>: la classe di supporto genera il percorso a partire dalla posizione di partenza e dalle coordinate target, poi Trolley lo invia a <em>pathexec</em> e in caso di successo aggiorna la posizione memorizzata. Essa, infatti, tiene traccia di posizione e direzione attuali del robot.</p>
  <p>È stata inoltre aggiunta un'operazione <code>trolleyRotate</code>, per permettere la rotazione senza movimento, usata per tornare rivolti nella posizione iniziale una volta tornati a HOME.</p>
  <p>
    <em>Basicrobot</em> permette di implementare il movimento del robot in modo indipendente dalla tecnologia, il che lo rende un componente utile in fase di testing. Infatti, prima di utilizzare un robot reale, sarà possibile osservare i movimenti del trolley grazie a <em>WEnv</em>.</p>
  <p>Come per <em>WasteService</em>, un errore blocca il sistema fino alla risoluzione manuale, per le ragioni già indicate.</p>
  <p>Come detto sopra, inoltre, il Trolley è una risorsa COaP osservabile, esponendo questi dati:</p>
  <pre>
    <div class="w3-code">state(work) // In questo SPRINT costante, espandibile per includere altri stati (stop, ecc.)
pos(X, Y) // Posizione numerica
{content(MAT, QNT)} // Opzionale, contenuto trasportato
</div>
  </pre>
  <p>
    <img src="../img/prog1_trolley.jpg" alt="architettura Trolley">
  </p>
  <h3 id="toc_41" class="w3-container w3-green">StorageManager</h3>
  <p>StorageManager, in modo analogo a Trolley, è rappresentato come classe Qak associata a classe Kotlin di support. Come Trolley rimane aperta all'espansione per un ipotetico caso reale.</p>
  <p>La risorsa COaP esposta mostra questi dati:</p>
  <pre>
    <div class="w3-code">// Per ogni materiale contenuto:
content(MAT, QNT, MAX)
</div>
  </pre>
  <h3 id="toc_42" class="w3-container w3-green">Struttura del sistema</h3>
  <p>La struttura finale del sistema nello SPRINT 1 è riassunta in questo grafico:</p>
  <p>
    <img src="../img/architettura1_progetto.jpg" alt="architettura progetto">
  </p>
  <h3 id="toc_43" class="w3-container w3-green">Immagine Docker</h3>
  <p>Viene fornito <a href="../../wasteservice.core/wasteservice.yaml">wasteservice.yaml</a> per eseguire il sistema con Docker. Ci si può connettere alla porta 8080 per aprire l'interfaccia per i WasteTruck usata per inviare richieste, e alla porta 8090 per visualizzare l'ambiente virtuale del robot.</p>
  <h2 id="toc_44" class="w3-container w3-teal">Riassunto SPRINT 1</h2>
  <p>Questo primo SPRINT riguardava questi requisiti:</p>
  <ul>
    <li>
      <strong>request</strong>: il <em>WasteService</em> accetta richieste di deposito da <em>Waste truck</em> che arrivano nella zona specificata come INDOOR, che specificicano il tipo di materiale da depositare.</li>
    <li>
      <strong>deposit</strong>: il <em>trolley</em>, quando viene attivato, raccoglie i materiali a INDOOR, e li deposita, in base al tipo, in GLASS BOX o PLASTIC BOX; questa è una <em>deposit action</em>.</li>
    <li>
      <strong>indoor-more-requests</strong>: il <em>trolley</em>, terminata una <em>deposit action</em>, torna a HOME solo se non ci sono altre richieste da gestire, altrimenti gestisce subito la richiesta successiva andando a INDOOR.</li>
  </ul>
  <h3 id="toc_45" class="w3-container w3-green">Analisi</h3>
  <p>Dopo la fase di analisi, l'architettura logica del sistema è stata così pensata:</p>
  <p>
    <img src="../img/arch_logica.png" alt="modello architettura logica">
  </p>
  <p>
    <img src="../img/arch_fsm_wasteservice.png" alt="diagramma stati WasteService">
  </p>
  <p>
    <a href="../../wasteservice.prototype/src/prototype_sprint1.qak">
      <strong>Prototipo eseguibile</strong>
    </a>
  </p>
  <p>Il sistema è stato pensato per usare la componente esterna BasicRobot22, per semplificare le interazioni con robot reali e virtuali.</p>
  <p>Sono stati realizzati, in fase di analisi, dei test plan già eseguibili sfruttando il prototipo in Qak, per ogni requisito. Sono dettagliati nella sezione apposita, e collegati di seguito:</p>
  <ul>
    <li>
      <a href="../../wasteservice.prototype/test/it/unibo/TestRequest.java">TestRequest.java</a>
    </li>
    <li>
      <a href="../../wasteservice.prototype/test/it/unibo/TestDeposit.java">TestDeposit.java</a>
    </li>
    <li>
      <a href="../../wasteservice.prototype/test/it/unibo/TestMoreRequests.java">TestMoreRequests.java</a>
    </li>
  </ul>
  <h3 id="toc_46" class="w3-container w3-green">Progetto</h3>
  <p>I punti salienti della fase di sviluppo sono i seguenti:</p>
  <ul>
    <li>
      <p>L'interfaccia per permettere ai WasteTruck è stata realizzata come applicazione web tramite il framework SpringBoot, che comunica con il sistema tramite WebSocket.</p>
    </li>
    <li>
      <p>WasteService è stato realizzato come due componenti distinte e collegate: un server web Spring Boot che fornisce la pagina per fare richieste e le gestisce, e un attore Qak che coordina la <em>deposit action</em> del Trolley.</p>
    </li>
    <li>
      <p>Il Trolley realizza il movimento interagendo con BasicRobot22, in particolare l'attore <em>pathexec</em>. Trolley genera il percorso per la destinazione, e lo invia a quest'ultimo attore.</p>
    </li>
    <li>
      <p>Ogni attore è una risorsa osservabile COaP con dati utili, permettendo più facile testing e futura espandibilità.</p>
    </li>
  </ul>
  <p>
    <img src="../img/architettura1_progetto.jpg" alt="architettura progetto">
  </p>
  <p>I test dell'analisi sono stati adattati all'implementazione:</p>
  <ul>
    <li>
      <a href="../../wasteservice.core/test/it/unibo/lenziguerra/wasteservice/wasteservice/TestRequest.java">TestRequest.java</a>
    </li>
    <li>
      <a href="../../wasteservice.core/test/it/unibo/lenziguerra/wasteservice/TestDeposit.java">TestDeposit.java</a>
    </li>
    <li>
      <a href="../../wasteservice.core/test/it/unibo/lenziguerra/wasteservice/TestMoreRequests.java">TestMoreRequests.java</a>
    </li>
  </ul>
  <p>Note sull'esecuzione:</p>
  <ul>
    <li>È necessario avviare BasicRobot22 prima di eseguire i test, è incluso un <a href="../../wasteservice.core/basicrobot22.yaml">file docker</a> per farlo facilmente, con le impostazioni della mappa che seguono il dominio del problema.</li>
    <li>I test vanno avviati un metodo alla volta, ed è necessario aggiornare la pagina di VirtualEnv di BasicRobot tra le esecuzioni, a causa di requisiti di VirtualEnv e Qak.</li>
  </ul>
  <p>Viene anche fornita un'<strong>immagine Docker</strong> per avviare il sistema in modo semplice: <a href="../../wasteservice.core/wasteservice.yaml">wasteservice.yaml</a>.</p>
</div></body>
