<head>
        <link rel="stylesheet" href="../css/w3.css"> 
        <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"> 
        <!-- <link rel="stylesheet" href="../css/doc.css"> -->
</head><body>
<style>

body {
    --sidebar-width: 400px;
    padding-left: calc( var( --sidebar-width ) + 100px);
    /* max-width: 1000px; */
    padding-right: 200px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.toc-sidebar {
    position: fixed;
    margin-left: 0;
    top: 0;
    left: 0;
    width: var(--sidebar-width);
    height: 100vh;
    padding: 0;
    background-color: rgb(31, 32, 32);
    font-size: 21px;
    font-weight: bold;
    text-transform: uppercase;
}
.toc-sidebar > * {
    padding: 10px
}
.toc-sidebar > div {
    width: 100%;
    padding-top: 20px;
    padding-bottom: 20px;
}
.toc-sidebar > div:hover {
    background-color: rgb(51, 51, 51);
}
.toc-sidebar a {
    color: white;
    text-decoration: unset;
    display: inline-block;
    width: 100%;
    height: 0;
    padding-bottom: 10%;
}

/* 
h3 strong {
    color: #800080; 
} */

img {
    max-width: 100%;
    max-height: 700px;
}

.w3-code {
    overflow-x: scroll;
}
</style>
<div>
  <h1 id="toc_1" class="w3-container w3-indigo">WasteService - Sprint 2</h1>
  <h5 id="toc_2" class="w3-panel">F. Lenzi, L. Guerra</h5>
  <section class="toc-sidebar">
    <div class="sidebar-index w3-deep-purple">
      <a href="./index.html">Indice generale</a>
    </div>
    <div>
      <a href="#toc_1">WasteService - Sprint 2</a>
    </div>
    <div>
      <a href="#toc_4">Requirements</a>
    </div>
    <div>
      <a href="#toc_6">Analisi dei Requisiti</a>
    </div>
    <div>
      <a href="#toc_13">Analisi del problema</a>
    </div>
    <div>
      <a href="#toc_22">Progettazione</a>
    </div>
    <div>
      <a href="#toc_37">Riassunto SPRINT 2</a>
    </div>
  </section>
  <h3 id="toc_3" class="w3-container w3-green">Indice</h3>
  <section class="toc">
    <ul>
      <li>
        <a href="#toc_1">WasteService - Sprint 2</a>
        <ul>
          <li>
            <a href="#toc_3">Indice</a>
          </li>
          <li>
            <a href="#toc_4">Requirements</a>
            <ul>
              <li>
                <a href="#toc_5">TFRequirements</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#toc_6">Analisi dei Requisiti</a>
            <ul>
              <li>
                <a href="#toc_7">Requisiti e chiarimenti</a>
              </li>
              <li>
                <a href="#toc_8">Glossario</a>
              </li>
              <li>
                <a href="#toc_9">Analisi dei requisiti</a>
              </li>
              <li>
                <a href="#toc_12">Materiale fornito dal committente</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#toc_13">Analisi del problema</a>
            <ul>
              <li>
                <a href="#toc_14">Componenti</a>
              </li>
              <li>
                <a href="#toc_16">Interazione</a>
              </li>
              <li>
                <a href="#toc_17">Posizione trolley</a>
              </li>
              <li>
                <a href="#toc_18">Architettura Logica</a>
              </li>
              <li>
                <a href="#toc_19">Test Plan</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#toc_22">Progettazione</a>
            <ul>
              <li>
                <a href="#toc_23">Struttura del software</a>
              </li>
              <li>
                <a href="#toc_24">Classi dati</a>
              </li>
              <li>
                <a href="#toc_25">Led</a>
              </li>
              <li>
                <a href="#toc_30">WasteServiceStatusGUI</a>
              </li>
              <li>
                <a href="#toc_33">Altro</a>
              </li>
              <li>
                <a href="#toc_34">Test</a>
              </li>
              <li>
                <a href="#toc_35">Struttura del sistema</a>
              </li>
              <li>
                <a href="#toc_36">Immagine Docker</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#toc_37">Riassunto SPRINT 2</a>
            <ul>
              <li>
                <a href="#toc_38">Analisi</a>
              </li>
              <li>
                <a href="#toc_39">Progetto</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </section>
  <h2 id="toc_4" class="w3-container w3-teal">Requirements</h2>
  <p>A company intends to build a WasteService for the <em>separate collection of waste</em>, composed of a set of elements:</p>
  <ol>
    <li>
      <p>a service area (rectangular, flat) that includes:</p>
      <ul>
        <li>
          <p>an INDOOR port, to enter waste material</p>
        </li>
        <li>
          <p>a PlasticBox container, devoted to store objects made of plastic, upto <strong>MAXPB</strong> kg of material.</p>
        </li>
        <li>
          <p>a GlassBox container, devoted to store objects made of glass, upto <strong>MAXGB</strong> kg of material.</p>
        </li>
      </ul>
      <p>The service area is free from internal obstacles, as shown in the following picture:</p>
      <blockquote>
        <p>
          <a href="https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/_images/WasteServiceRoom.PNG">
            <img src="https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/_images/WasteServiceRoom.PNG" alt="WasteServiceRoom.PNG">
          </a>
        </p>
      </blockquote>
    </li>
    <li>
      <p>a DDR robot working as a transport trolley, that is intially situated in its HOME location. The transport trolley has the form of a square of side length <strong>RD</strong>.</p>
      <p>The transport trolley is used to performa a deposit action that consists in the following phases:</p>
      <ol>
        <li>
          <p>pick up a waste-load from a Waste truck located on the INDOOR</p>
        </li>
        <li>
          <p>go from the INDOOR to the proper waste container</p>
        </li>
        <li>
          <p>deposit the waste-load in the container</p>
        </li>
      </ol>
    </li>
    <li>
      <p>a Service-manager (an human being) which supervises the state of the service-area by using a WasteServiceStatusGUI.</p>
    </li>
    <li>
      <p>a Sonar and a Led connected to a RaspnerryPi. The Led is used as a <em>warning devices</em>, according to the following scheme:</p>
      <ul>
        <li>
          <p>the Led is <strong>off</strong> when the transport trolley is at HOME</p>
        </li>
        <li>
          <p>the Led <strong>blinks</strong> while the transport trolley is moving</p>
        </li>
        <li>
          <p>the Led is <strong>on</strong> when transport trolley is stopped.</p>
        </li>
      </ul>
      <p>The Sonar is used as an ‘alarm device’: when it measures a distance less that a prefixed value <strong>DLIMT</strong>, the transport trolley must be stopped. It will be resumed when Sonar detects again a distance higher than <strong>DLIMT</strong>.</p>
    </li>
  </ol>
  <h3 id="toc_5" class="w3-container w3-green">TFRequirements</h3>
  <p>The main goal of the WasteService software is to allow a Waste truck to deposit its load of <strong>TruckLoad</strong> kg plastic or glass in the proper container.</p>
  <p>The global story can be described as follows:</p>
  <ol>
    <li>
      <p>The Waste truck driver approaches the INDOOR and sends (using a smart device) a request to store the load, by specifyng the type of the material (plastic or glass) and its TruckLoad.</p>
    </li>
    <li>
      <p>The WasteService sends the answer <em>loadaccept</em> if the final content of proper container will not surpass the maximum value allowed (<em>MAXPB</em> or <em>MAXGB</em>). Otherwise, it sends the answer <em>loadrejecetd</em> and the Waste truck leaves the INDOOR area.</p>
    </li>
    <li>
      <p>When the load is accepted, the transport trolley reaches the INDOOR, picks up the material, goes to the proper container and settles the material. During this activity, the WasteService <strong>blinks</strong> the Led</p>
    </li>
    <li>
      <p>When the deposit action is terminated, the transport trolley excutes another deposit command (if any) or returns to its HOME.</p>
    </li>
  </ol>
  <p>The WasteService must create a WasteServiceStatusGUI that shows to the <em>Service-manager</em>:</p>
  <ul>
    <li>
      <p>the current state of the transport trolley and it position in the room</p>
    </li>
    <li>
      <p>the current weigth of the material stored in the two waste-containers</p>
    </li>
    <li>
      <p>the current state of the Led</p>
    </li>
  </ul>
  <h2 id="toc_6" class="w3-container w3-teal">Analisi dei Requisiti</h2>
  <p>Per ogni requisito analizzato in questo SPRINT è stato incluso un modello eseguibile in <a href="../#scelta-del-linguaggio-di-modellazione">Qak</a>.</p>
  <h3 id="toc_7" class="w3-container w3-green">Requisiti e chiarimenti</h3>
  <ul>
    <li>
      <p>
        <strong>request</strong>: il <em>WasteService</em> accetta richieste di deposito da <em>Waste truck</em> che arrivano nella zona specificata come INDOOR, che specificicano il tipo di materiale da depositare</p>
      <ul>
        <li>il sistema può controllare se c'è spazio per un certo materiale: accetta (risposta <em>loadaccept</em>), e rifiuta (risposta <em>loadrejected</em>) le richieste di deposito in caso contrario</li>
      </ul>
      <ol>
        <li>
          <blockquote>
            <p>Domanda: le richieste possono essere gestite anche mentre il robot è in attività?</p>
          </blockquote>
          <p>Sì, potrebbe arrivare altro camion che chiede.</p>
        </li>
        <li>
          <blockquote>
            <p>Domanda: solo un camion alla volta in INDOOR?</p>
          </blockquote>
          <p>Sì.</p>
        </li>
      </ol>
    </li>
    <li>
      <p>
        <strong>deposit</strong>: il <em>trolley</em>, quando viene attivato, raccoglie i materiali a INDOOR, e li deposita, in base al tipo, in GLASS BOX o PLASTIC BOX; questa è una <em>deposit action</em>:</p>
      <ol>
        <li>Raccolta di rifiuti da <em>Waste truck</em> in INDOOR</li>
        <li>Andare da INDOOR a contenitore rifiuti (* BOX)</li>
        <li>Depositare rifiuti nel contenitore</li>
      </ol>
    </li>
    <li>
      <p>
        <strong>indoor-more-requests</strong>: il <em>trolley</em>, terminata una <em>deposit action</em>, torna a HOME solo se non ci sono altre richieste da gestire, sennò gestisce subito la richiesta successiva andando a INDOOR</p>
    </li>
    <li>
      <p>
        <strong>led</strong>: nel sistema è presente un led che:</p>
      <ul>
        <li>è <em>acceso</em> se il <em>trolley</em> è a HOME</li>
        <li>
          <em>lampeggia</em> se il <em>trolley</em> è in attività</li>
        <li>è <em>spento</em> se il trolley è in stato di <em>stop</em>
        </li>
      </ul>
    </li>
    <li>
      <p>
        <strong>sonar-stop</strong>: è presente un <em>sonar</em> che, se misura una distanza sotto DLIMIT (valore prefissato), mette il <em>trolley</em> in stato di <em>stop</em> fino a che la distanza non torna a DLIMIT, nel qual caso il <em>trolley</em> riparte</p>
      <ol>
        <li>
          <blockquote>
            <p>Domanda: cosa vuol dire precisamente <em>stop</em>? Torna a HOME o rimane lì?</p>
          </blockquote>
          <p>Si ferma e basta.</p>
        </li>
      </ol>
    </li>
    <li>
      <p>
        <strong>gui</strong>: è presente una gui (<em>WasteServiceStatusGUI</em>) che mostra i seguenti dati:</p>
      <ul>
        <li>Stato del <em>trolley</em> e sua posizione</li>
      </ul>
      <ol>
        <li>
          <blockquote>
            <p>Domanda: Posizione del trolley: deve essere precisa o informazione più generale (INDOOR, in mezzo, HOME, ecc)?</p>
          </blockquote>
          <p>Basta una posizione più generale.</p>
        </li>
      </ol>
      <ul>
        <li>Carico depositato attuale (in kg)</li>
        <li>Stato del Led (acceso/spento/lampeggiante)</li>
      </ul>
    </li>
  </ul>
  <p>In questo secondo SPRINT verranno analizzati i requisiti <strong>led</strong> e <strong>gui</strong>, data la natura simile di interfaccia sullo stato del sistema e sviluppato il software annesso.</p>
  <h3 id="toc_8" class="w3-container w3-green">Glossario</h3>
  <ul>
    <li>
      <p>
        <em>WasteService</em>: il servizio centrale che risponde alle richieste dei <em>waste truck</em>
      </p>
    </li>
    <li>
      <p>
        <em>Waste truck</em>: i camion che arrivano dall'esterno a depositare rifiuti</p>
    </li>
    <li>
      <p>Area di servizio: <strong>INDOOR</strong>, <strong>PlasticBox</strong>, <strong>GlassBox</strong>, aree definite nella creazione del sistema e punti di riferimento per il <em>trolley</em>. In particolare:</p>
      <ul>
        <li>INDOOR: area dove i <em>waste truck</em> si fermano a lasciare il proprio carico, facendo una richiesta di deposito. Essa può contenere un <em>waste truck</em> alla volta</li>
        <li>PlasticBox: area dove depositare la plastica</li>
        <li>GlassBox: area dove depositare il vetro</li>
      </ul>
    </li>
    <li>
      <p>
        <em>transport trolley</em> (o <em>trolley</em>): robot DDR (differential drive robot), di dimensione approssimabile a quadrato di lato RD, usato per trasportare i rifiuti nel sistema</p>
    </li>
    <li>
      <p>
        <em>Service-manager</em>: umano che supervisiona il sistema tramite la <em>WasteServiceStatusGUI</em>
      </p>
    </li>
    <li>
      <p>
        <em>Sonar</em>: sensore che misura distanza</p>
    </li>
    <li>
      <p>
        <em>Led</em>: spia luminosa</p>
    </li>
  </ul>
  <h3 id="toc_9" class="w3-container w3-green">Analisi dei requisiti</h3>
  <h4 id="toc_10">Analisi <strong>led</strong>:</h4>
  <p>La gestione del Led verrà fatta tramite il software fornito dal committente, gli script <em>led25GpioTurnOn.sh</em> e <em>led25GpioTurnOff.sh</em>. L'azienda dispone già di una libreria per gestire tramite Java il Led con questi script, cioè <em>it.unibo.radarSystem22.domain</em>, quindi sarà opportuno utilizzarla.</p>
  <p>Dai requisiti, si evincono tre primitive che il led deve poter eseguire: accendersi, spegnersi, e lampeggiare, che verranno chiamate <em>turnOn</em>, <em>turnOff</em>, <em>blink</em>. Il software fornito e la libreria che lo controlla implementano solo le prime due, quindi questo <em>abstraction gap</em> va colmato realizzando un componente intermedio, che chiameremo <strong>BlinkLed</strong>, che implementa la terza primitiva. Questo componente deve comunicare con il resto del sistema, quindi viene modellato come attore.</p>
  <p>
    <img src="../img/sprint2_req_led.png" alt="">
  </p>
  <p>La natura precisa di questo attore lascia punti aperti che verranno gestiti in fase di analisi del problema.</p>
  <p>Inoltre, il Led deve poter conoscere lo stato del Trolley.
Anche questo può essere implementato in più modi che rimangono un punto aperto.</p>
  <p>
    <a href="../../model.requisiti/src/led.qak">Modello eseguibile Led</a>
  </p>
  <p>Intanto però, può già essere abbozzato un TestPlan:</p>
  <p>
    <a href="../../model.requisiti/test/it/unibo/TestLed.kt">Test plan Led</a>
  </p>
  <h4 id="toc_11">Analisi <strong>gui</strong>:</h4>
  <p>Date le risorse pre-esistenti dell'azienda e il lavoro molto ridotto rispetto alle alternative, è opportuno implementare <em>WasteServiceStatusGUI</em> come web-app.</p>
  <p>Anche in questo caso, dovendo comunicare con il resto del sistema, è opportuno modellarla come attore:</p>
  <p>
    <img src="../img/sprint2_req_gui.png" alt="">
  </p>
  <p>In questo documento, il nome <em>StatusGUI</em> verrà usato come sinonimo di <em>WasteServiceStatusGUI</em> per comodità.</p>
  <p>Come per il Led, il tipo di comunicazione con il resto del sistema rimane un punto aperto.</p>
  <p>
    <a href="../../model.requisiti/src/gui.qak">Modello eseguibile Gui</a>
  </p>
  <h3 id="toc_12" class="w3-container w3-green">Materiale fornito dal committente</h3>
  <ul>
    <li>
      <p>Robot DDR: viene fornita una componente software, <em>BasicRobot22</em>, che implementa comandi primitivi <em>MOVE = w | s | l | r | h</em>, e permette di fare <em>step</em> in avanti per un certo tempo.</p>
    </li>
    <li>
      <p>Sonar: viene fornito un programma in C, <em>SonarAlone.c</em>, che stampa su standard output la distanza attualmente rilevata dal sonar, configurando le porte GPIO in questo modo:</p>
      <ul>
        <li>Porta VCC : pin fisico 4 (+5v)</li>
        <li>Porta GND : pin fisico 6 (GND)</li>
        <li>Porta TRIG: pin fisico 11 (WPI 0, BCM 17)</li>
        <li>Porta ECHO: pin fisico 13 (WPI 2, BCM 27)</li>
      </ul>
    </li>
    <li>
      <p>Led: vengono forniti gli script bash e <em>led25GpioTurnOn.sh</em> e <em>led25GpioTurnOff.sh</em> per accendere e spegnere un Led connesso alla porta GPIO 25 di un Raspberry Pi.</p>
    </li>
  </ul>
  <h2 id="toc_13" class="w3-container w3-teal">Analisi del problema</h2>
  <h3 id="toc_14" class="w3-container w3-green">Componenti</h3>
  <h4 id="toc_15">Requisito <strong>led</strong> - componenti</h4>
  <p>Emergono due opzioni principali su come gestire il Led:</p>
  <ul>
    <li>
      <p>Usare un solo attore BlinkLed che gestisce i dati di dominio e interagisce direttamente con il dispositivo tramite la libreria esistente e il software fornito. Quindi, questo singolo componente riceverebbe i dati dello stato del Trolley e si occuperebbe di accensione e spegnimento del Led.</p>
    </li>
    <li>
      <p>Dividere gli incarichi tra due componenti:</p>
      <ul>
        <li>BlinkLed, che realizzerebbe le tre primitive di <em>turnOn</em>, <em>turnOff</em>, <em>blink</em> e interagirebbe con il dispositivo tramite la libreria, attraverso istruzioni ricevute dall'esterno.</li>
        <li>LedController, che riceverebbe i dati dello stato del trolley e interagirebbe con BlinkLed.</li>
      </ul>
    </li>
  </ul>
  <p>
    <strong>Conclusione.</strong> Si ritiene migliore la seconda opzione, vale a dire <strong>dividere gli incarichi</strong>, visto che rispetta il principio di singola responsabilità. Inoltre, questo permetterebbe il riutilizzo dell'attore BlinkLed in altri contesti, essendo agnostico al dominio.</p>
  <h3 id="toc_16" class="w3-container w3-green">Interazione</h3>
  <p>Il problema della comunicazione per <strong>led</strong> e <strong>gui</strong> è analogo, quindi verranno analizzati insieme.</p>
  <p>Escludendo di usare comunicazione punto-punto come dispatch e richieste, data la scarsa espandibilità e la complicazione nella necessità di modificare ogni attore da analizzare, le opzioni attuali sono due:</p>
  <ul>
    <li>
      <p>Usare eventi: si potrebbero aggiungere emissioni di eventi contenenti i dati di stato attuale dei vari attori di interesse per Led e WasteServiceStatusGui, incluso il Led i cui dati sono visualizzati dalla Gui.</p>
      <pre>
        <div class="w3-code">Event trolleyStatus : trolleyStatus(STATUS,POS)
Event storageStatus : storageStatus(CONTENTS)
Event ledStatus : ledStatus(STATUS) //on|blink|off
</div>
      </pre>
    </li>
    <li>
      <p>Osservabilità: come detto nel progetto dello SPRINT 1, i vari attori sono osservabili tramite COAP. Quindi un'opzione sarebbe rendere LedController e StatusGUI osservatori degli attori rilevanti (e rendere osservabile il Led) e aggiungere alle informazioni osservabili degli attori di interesse eventuali dati mancanti.</p>
    </li>
  </ul>
  <p>
    <strong>Conclusione.</strong> Viene ritenuta come opzione migliore la seconda, l'uso di <strong>observer</strong>, visto che gli attori creati nello SPRINT 1 sono già risorse osservabili con le informazioni necessarie; quindi, non sarebbe necessaria alcuna modifica al software già sviluppato per adempiere a questo requisito, il che sarebbe un grande vantaggio. Inoltre, il fatto che COAP sia un protocollo già definito renderebbe ancora più facile l'estendibilità.</p>
  <p>In luce di queste considerazioni, sono quindi aggiornati i modelli eseguibili di Led e Gui:</p>
  <ul>
    <li>
      <a href="../../model.problema/src/pro_led.qak">Modello eseguibile Led</a>
    </li>
    <li>
      <a href="../../model.problema/src/pro_gui.qak">Modello eseguibile Gui</a>
    </li>
  </ul>
  <p>Per realizzarli, è stata sviluppata una utility per Qak per permettere agli attori di agire da osservatori, oltre che da risorse osservabili. Ulteriori dettagli sono presenti nel file <a href="qakactor.observer.html">qakactor.observer.md</a>.</p>
  <h3 id="toc_17" class="w3-container w3-green">Posizione trolley</h3>
  <p>La posizione del Trolley, come da analisi dello Sprint 1, non è ad esso nota in termini di nomi del dominio ("home", "indoor", ecc.) essendo esso usato come "attuatore", ma solo in termini di coordinate numeriche. La componente che conosce la posizione del Trolley in termini di nomi dei luoghi è WasteService.</p>
  <p>Dovendo StatusGUI conoscere la posizione del Trolley in termini di nomi dei luoghi, si pongono due possibilità:</p>
  <ul>
    <li>
      <p>StatusGUI potrebbe osservare anche WasteService, che comunque già fornisce questa informazione come risorsa.</p>
    </li>
    <li>
      <p>StatusGUI potrebbe continuare ad osservare solo il Trolley e a decodificare il nome delle posizioni dalla configurazione.</p>
    </li>
  </ul>
  <p>
    <strong>Conclusioni.</strong> È stato deciso il primo approccio, ritenuto più vicino al principio di singola responsabilità; invece di mettere la logica di rilevazione del luogo dalla posizione in più componenti, la si mette in un componente solo (WasteService) e si chiede ad esso lo stato attuale del dato.</p>
  <p>LedController ha un problema simile, cioè sapere se Trolley si trovi a HOME o meno: viene usata una soluzione analoga.</p>
  <h3 id="toc_18" class="w3-container w3-green">Architettura Logica</h3>
  <p>Ecco quindi l'architettura logica finale del sistema in generale per questo SPRINT:</p>
  <p>
    <img src="../img/sprint2_pro_arch.jpg" alt="modello architettura logica">
  </p>
  <p>
    <a href="../../wasteservice.prototype/src/prototype_sprint2.qak">
      <strong>Modello eseguibile generale / prototipo.</strong>
    </a> Si noti come rispetto al modello eseguibile dello SPRINT 1, non sia stato necessario modificare niente del codice preesistente ma sia bastato aggiungere gli attori-osservatori.</p>
  <h3 id="toc_19" class="w3-container w3-green">Test Plan</h3>
  <h4 id="toc_20">TestPlan: led</h4>
  <p>Test plan in Kotlin: <a href="../../wasteservice.prototype/test/it/unibo/TestLed.kt">TestLed.kt</a>
  </p>
  <ul>
    <li>
      <strong>Test Led</strong>: creazione di server COAP "fasullo" allo stesso indirizzo del contesto del sistema principale osservato. Invio di dati che portano ai vari stati del Led, poi verifica che questi stati siano stati raggiunti.</li>
  </ul>
  <h4 id="toc_21">TestPlan: gui</h4>
  <p>Test plan in Kotlin: <a href="../../wasteservice.prototype/test/it/unibo/TestGui.kt">TestGui.kt</a>. Nota: lanciare un test alla volta, a causa di interazioni tra Qak e JUnit.</p>
  <ul>
    <li>
      <strong>Test Gui</strong>: creazione di server COAP "fasullo" allo stesso indirizzo del contesto del sistema principale osservato. Invio di dati che portano a vari stati della Gui, e verifica che la pagina risultante venga modificata correttamente.</li>
  </ul>
  <h2 id="toc_22" class="w3-container w3-teal">Progettazione</h2>
  <p>La progettazione e lo sviluppo delle componenti software stabilite in fase di analisi è stata divisa in questo modo:</p>
  <ul>
    <li>BlinkLed, LedController: F. Lenzi</li>
    <li>WasteServiceStatusGUI: L. Guerra</li>
  </ul>
  <h3 id="toc_23" class="w3-container w3-green">Struttura del software</h3>
  <p>Dato che entrambi i componenti non interagivano con il sistema Qak se non tramite l'osservazione della risorsa server COaP, sono stati realizzati come <strong>semplici oggetti</strong>, non attori, dotati di capacità di osservazione mediante una <code>CoapConnection</code> (libreria <em>unibo.comm22</em>) che sfrutta la libreria Californium per Coap.</p>
  <p>Questo permette di semplificare abbastanza la struttura, non richiedendo contesti di attori e conseguenti adattatori observer-attore come quello realizzato per rappresentare il modello dell'analisi. Infatti, i progetti dei due componenti non includono o conoscono neanche il framework Qak.</p>
  <p>I componenti sono stati contenuti in due nuovi progetti:</p>
  <ul>
    <li>
      <em>wasteservice.led</em>: contiene le classi corrispondenti a BlinkLed e LedController.</li>
    <li>
      <em>wasteservice.statusgui</em>: contiene il server Spring Boot che gestisce la WasteServiceGUI.</li>
  </ul>
  <p>La struttura dei package diventa la seguente (evidenziati solo i cambiamenti importanti):</p>
  <ul>
    <li>wasteservice.shared<ul>
        <li>
          <em>it.unibo.lenziguerra.wasteservice</em> (aggiunti nuovi enumerativi, test fixture, e classi minori)</li>
        <li>it.unibo.lenziguerra.wasteservice.utils</li>
        <li>+ <em>it.unibo.lenziguerra.wasteservice.data</em> (classi dati, vedi sotto)</li>
      </ul>
    </li>
    <li>wasteservice.core<ul>
        <li>it.unibo.lenziguerra.wasteservice.wasteservice</li>
        <li>it.unibo.lenziguerra.wasteservice.trolley</li>
        <li>it.unibo.lenziguerra.wasteservice.storage</li>
        <li>
          <em>
            <code>wasteservice.qak</code>
          </em> (uso delle nuove classi dati)</li>
      </ul>
    </li>
    <li>
      <strong>wasteservice.led</strong>
      <ul>
        <li>
          <em>it.unibo.lenziguerra.wasteservice.led</em>
        </li>
      </ul>
    </li>
    <li>
      <strong>wasteservice.statusgui</strong>
      <ul>
        <li>
          <em>it.unibo.lenziguerra.wasteservice.statusgui</em>
        </li>
      </ul>
    </li>
  </ul>
  <h3 id="toc_24" class="w3-container w3-green">Classi dati</h3>
  <p>Come da analisi, non sarebbe servito modificare il progetto core per permettere il funzionamento dei nuovi componenti, essendo gli attori già impostati per essere osservabili con dati rilevanti. Sono state comunque fatte modifiche minori, soprattutto per usare le <strong>classi dati</strong> aggiunte in questo SPRINT.</p>
  <p>Per strutturare in modo più semplice e consistente il formato dei dati contenuti nelle risorse osservabili COaP, questi dati sono stati incapsulati in apposite <em>data class</em> Kotlin, contenute in <em>wasteservice.shared:it.unibo.lenziguerra.wasteservice.data</em>. Esse hanno metodi <code>fromProlog</code> e <code>toString</code> per convertire i dati da stringa osservata a dato di dominio, con enumerativi vari rilevanti:</p>
  <pre>
    <div class="w3-code">data class TrolleyStatus (val status: State, val pos: Array&lt;Int&gt;, val contentType: WasteType?, val contentAmount: Float) {
    enum class State {
        WORK, STOPPED
    }

    companion object {
        fun fromProlog(prolStr: String): TrolleyStatus {
           [...]
        }
    }

    override fun toString(): String {
        return "state(${status.toString().lowercase()})\npos(${pos[0]},${pos[1]})" +
                (contentType?.let { "\ncontent($contentType,$contentAmount)" } ?: "")
    }
}
</div>
  </pre>
  <p>La stringa restituita da queste classi è quella che viene passata a <code>updateResource</code> nei vari attori (o equivalente per il Led).</p>
  <h3 id="toc_25" class="w3-container w3-green">Led</h3>
  <p>Il led, come da analisi, viene gestito tramite la libreria già realizzata <em>it.unibo.radarSystem22.domain</em>, che a sua volta interagisce con il software del committente (<em>led25GpioTurnOn.sh</em> e <em>led25GpioTurnOff.sh</em>).</p>
  <p>Come sopra i due componenti da analisi (BlinkLed e LedController) sono realizzati non come attori Qak, ma come POJO. In particolare, vengono realizate queste classi:</p>
  <ul>
    <li>
      <p>
        <strong>BlinkLed</strong>: wrapper per le classi di <em>radarSystem22.domain</em>, che permette di impostare il led, oltre che ad acceso o spento, a uno stato di lampeggiamento, ed è osservabile. Analogo all'attore BlinkLed in analisi.</p>
    </li>
    <li>
      <p>
        <strong>LedController</strong>: analogo a LedController in analisi, controlla un BlinkLed e osserva Trolley e WasteService.</p>
    </li>
    <li>
      <p>
        <strong>BlinkLedCoapServer</strong>: un server COaP standalone, per rendere osservabile il BlinkLed come risorsa.</p>
    </li>
    <li>
      <p>
        <strong>LedContainer</strong>: integra il sotto-sistema, istanziando e collegando i vari componenti.</p>
    </li>
  </ul>
  <h4 id="toc_26">BlinkLed</h4>
  <p>Da requisiti, il led deve poter essere impostato in stato di lampeggiamento, acceso, o spento, realizzando le primitive <em>turnOn</em>, <em>turnOff</em>, e <em>blink</em>. L'interfaccia della classe BlinkLed, <code>IBlinkLed</code>, è quindi la seguente:</p>
  <pre>
    <div class="w3-code">interface IBlinkLed {
    fun turnOn()
    fun turnOff()
    fun blink()

    val status: BlinkLedState
    var updateHandler: ((BlinkLedState) -&gt; Unit)?
}
</div>
  </pre>
  <p>
    <code>BlinkLedState</code> è un nuovo enumerativo che corrisponde ai tre stati possibili. La funzione updateHandler, invece, è un callback che può essere impostato per rendere osservabile il <code>BlinkLed</code>, chiamato a ogni cambiamento di stato.</p>
  <p>Il lampeggiamento in <code>BlinkLed</code> è realizzato creando un thread apposito al cambiamento di stato:</p>
  <pre>
    <div class="w3-code">BlinkLedState.BLINKING -&gt; thread {
    while (status == BlinkLedState.BLINKING) {
        led.turnOn()
        CommUtils.delay(500)
        led.turnOff()
        CommUtils.delay(500)
    }
}
</div>
  </pre>
  <p>esso non viene attivato se il Led sta già lampeggiando.</p>
  <h4 id="toc_27">LedController</h4>
  <p>
    <code>LedController</code> riceve un <code>IBlinkLed</code>, e crea due connessioni Coap con il contesto Qak di <em>wasteservice.core</em> per osservare lo stato sia di WasteService che di Trolley, come da analisi. Il funzionamento è analogo all'attore dell'analisi, con due handler Coap per gestire le due risorse osservate.</p>
  <h4 id="toc_28">BlinkLedCoapServer</h4>
  <p>
    <code>BlinkLedCoapServer</code> è un semplice wrapper per <code>CoapServer</code> di Californium, che contiene una <code>CoapResourceBlinkLed</code>, contenente un riferimento a <code>ILed</code>. Offre una funzione sendUpdates che invia aggiornamenti a tutti gli Observer della risorsa connessi. Espone la risorsa all'Uri <em>/led</em>.</p>
  <h4 id="toc_29">LedContainer</h4>
  <p>
    <code>LedContainer</code> si limita a configurare i vari componenti e istanziarli, e offrire il punto di ingresso del sistema. Il main, infatti, è lì contenuto. In particolare, crea un istanza di <code>ILed</code> di <em>radarSystem22.domain</em> reale o mock in base alla configurazione della libreria, contenuta in <em>DomainSystemConfig.json</em>.</p>
  <p>Inoltre, rende il led osservabile impostando il callback per lanciare <em>sendUpdates</em> nel <code>BlinkLedCoapServer</code>:</p>
  <pre>
    <div class="w3-code">led.updateHandler = { ledServer.sendUpdates() }
</div>
  </pre>
  <h3 id="toc_30" class="w3-container w3-green">WasteServiceStatusGUI</h3>
  <p>Come da analisi, WasteServiceStatusGUI è stata implementata come web application. Il server web è realizzato, come per WasteService, tramite il framework Spring Boot. In particolare, la pagina web rimane connessa al server tramite <em>WebSocket</em>, per permettere aggiornamenti in diretta dei dati da monitorare senza aggiornare la pagina.</p>
  <p>L'osservazione dei dati è svolta dal <code>WebSocketHandler</code> Spring che gestisce le connessioni, implementato nella classe <code>StatusGuiWebsocketHandler</code>.</p>
  <h4 id="toc_31">StatusGuiWebsocketHandler</h4>
  <p>
    <code>StatusGuiWebsocketHandler</code> tiene traccia di ogni sessione di WebSocket attualmente attiva, e contiene le 4 <code>CoapConnection</code> ai componenti del sistema osservati (gli attori <em>wasteservice</em>, <em>trolley</em>, <em>storagemanager</em> e il <code>BlinkLedCoapServer</code>), ciascuna gestita da un Observer. Gli Observer inviano a ogni sessione WebSocket attiva aggiornamenti sui dati ogni volta che la risorsa osservata cambia.</p>
  <p>L'handler in sè accetta un unico input da parte delle sessioni di WebSocket, vale a dire la stringa <em>get</em>, alla quale risponde con aggiornamenti su tutti i dati. Questa viene usata al caricamento della pagina per inizializzare la StatusGUI.</p>
  <h4 id="toc_32">Observer</h4>
  <p>Gli observer sono estensioni di <code>CoapHandler</code> della libreria Californium, una classe per ogni risorsa osservata. Le classi sono presenti nel file <a href="../../wasteservice.statusgui/src/main/kotlin/it/unibo/lenziguerra/wasteservice/statusgui/Observers.kt">Observers.kt</a>. Ogni observer contiene un riferimento alla lista di sessioni WebSocket attive, e invia aggiornamenti alla ricezione dei dati.</p>
  <h3 id="toc_33" class="w3-container w3-green">Altro</h3>
  <p>Sono state fatte altre modifiche minori a <em>wasteservice.core</em> e <em>wasteservice.shared</em>:</p>
  <ul>
    <li>Aggiunto un dispatch <em>updateState</em> a Trolley per impostare il suo stato a <em>stopped</em> in caso di errore.</li>
    <li>Aggiunto gruppo source <em>testFixtures</em> in <em>wasteservice.shared</em> per condividere librerie di testing con gli altri progetti senza includerle nella versione di distribuzione.</li>
    <li>Correzione all'uso di <code>WebSocketHandler</code> di Spring Boot in <code>WasteServiceServer</code> per coerenza con StatusGUI, usa <em>@Component</em> e <em>@AutoWired</em> per evitare di inizializzare l'handler 2 volte con Spring.</li>
  </ul>
  <h3 id="toc_34" class="w3-container w3-green">Test</h3>
  <p>I test dell'analisi sono stati adattati al sistema, funzionando nello stesso modo, cioè creazione di contesto Qak con attori mock la cui risorsa viene arbitrariamente pilotata nel test e osservata dai componenti da testare. TestGui è eseguibile anche dalla classe di test, senza dover per forza eseguire un test alla volta.</p>
  <p>I test possono inoltre essere eseguiti senza avviare nessun software oltre al test, invece di richiedere WEnv/BasicRobot come nello SPRINT precedente. Questo grazie alla maggiore flessibilità data dalla struttura ad Observer.</p>
  <ul>
    <li>
      <a href="../../wasteservice.statusgui/src/test/kotlin/it/unibo/lenziguerra/wasteservice/statusgui/TestGui.kt">TestGui.kt</a>
    </li>
    <li>
      <a href="../../wasteservice.led/src/test/kotlin/TestLed.kt">TestLed.kt</a>
    </li>
  </ul>
  <p>È stato inoltre aggiunto un test per verificare il corretto funzionamento del lampeggiamento in BlinkLed:</p>
  <ul>
    <li>
      <a href="../../wasteservice.led/src/test/kotlin/BlinkLedTest.kt">BlinkLedTest.kt</a>
    </li>
  </ul>
  <h3 id="toc_35" class="w3-container w3-green">Struttura del sistema</h3>
  <p>La struttura finale del sistema nello SPRINT 2 è riassunta in questo grafico:</p>
  <p>
    <img src="../img/architettura2_progetto.jpg" alt="modello architettura progetto">
  </p>
  <p>Le connessioni di WasteServiceStatusGUI sono riassunte per testo per semplificare il grafico.</p>
  <h3 id="toc_36" class="w3-container w3-green">Immagine Docker</h3>
  <p>Vengono forniti i file Docker-compose elencati in seguito. Ci si può connettere alla porta 8080 per aprire l'interfaccia per i WasteTruck usata per inviare richieste, alla porta 8090 per visualizzare l'ambiente virtuale del robot, e alla porta 8095 per visualizzare WasteServiceStatusGUI.</p>
  <ul>
    <li>
      <p>
        <a href="../../wasteservice2_withledmock.yaml">wasteservice2_withledmock.yaml</a>: esegue tutto il sistema in locale, usando un mock per il Led che stampa lo stato attuale su standard output.</p>
    </li>
    <li>
      <p>
        <a href="../../wasteservice2_noled.yaml">wasteservice2_noled.yaml</a>: esegue il sistema senza la parte di wasteservice.led; essa va eseguita fuori da Docker sul Raspberry Pi, il quale IP va configurato dentro a questo file yaml nel campo <strong>wasteservice.led</strong> sotto <strong>extra_hosts</strong> del servizio <strong>wasteservice.statusgui</strong>. Per trasferire facilmente i file di distribuzione al Raspberry Pi viene fornito lo script <a href="../../wasteservice.led/scpDistrToRasp.sh">scpDistrToRasp.sh</a>, dove occorre configurare l'hostname/IP del raspberry al posto di <code>raspi</code> nei vari comandi.</p>
    </li>
  </ul>
  <h2 id="toc_37" class="w3-container w3-teal">Riassunto SPRINT 2</h2>
  <p>Il secondo SPRINT riguardava questi requisiti:</p>
  <ul>
    <li>
      <strong>led</strong>: nel sistema è presente un led che:<ul>
        <li>è <em>acceso</em> se il <em>trolley</em> è a HOME</li>
        <li>
          <em>lampeggia</em> se il <em>trolley</em> è in attività</li>
        <li>è <em>spento</em> se il trolley è in stato di <em>stop</em>
        </li>
      </ul>
    </li>
    <li>
      <strong>gui</strong>: è presente una gui (<em>WasteServiceStatusGUI</em>) che mostra i seguenti dati:<ul>
        <li>Stato del <em>trolley</em> e sua posizione</li>
      </ul>
    </li>
  </ul>
  <h3 id="toc_38" class="w3-container w3-green">Analisi</h3>
  <p>In fase di analisi, è stato deciso di realizzare i due nuovi componenti sfruttando il pattern Observer, rendendoli Observer delle risorse osservabili realizzate nello SPRINT 1.</p>
  <p>Dopo la fase di analisi, l'architettura logica del sistema è stata così pensata:</p>
  <p>
    <img src="../img/sprint2_pro_arch.jpg" alt="modello architettura logica">
  </p>
  <p>
    <a href="../../wasteservice.prototype/src/prototype_sprint2.qak">
      <strong>Modello eseguibile generale / prototipo.</strong>
    </a> Si noti come rispetto al modello eseguibile dello SPRINT 1, non sia stato necessario modificare niente del codice preesistente ma sia bastato aggiungere gli attori-osservatori.</p>
  <p>È stato realizzato un supporto a Qak per rendere un attore Observer di altri attori o risorse Coap, <a href="qakactor.observer.html">qakactor.observer</a>.</p>
  <p>Sono usati per interagire con il led i componenti forniti dal committente, <em>led25GpioTurnOn.sh</em> e <em>led25GpioTurnOff.sh</em>, controllati con la libreria <em>it.unibo.radarSystem22.domain</em> realizzata per progetti precedenti.</p>
  <p>Sono stati realizzati, in fase di analisi, dei test plan già eseguibili sfruttando il prototipo in Qak, per ogni requisito. Sono dettagliati nella sezione apposita, e collegati di seguito:</p>
  <ul>
    <li>
      <a href="../../wasteservice.prototype/test/it/unibo/TestLed.kt">TestLed.kt</a>
    </li>
    <li>
      <a href="../../wasteservice.prototype/test/it/unibo/TestGui.kt">TestGui.kt</a>. Nota: lanciare un test alla volta, a causa di interazioni tra Qak e JUnit.</li>
  </ul>
  <h3 id="toc_39" class="w3-container w3-green">Progetto</h3>
  <p>I punti salienti della fase di sviluppo sono i seguenti:</p>
  <ul>
    <li>
      <p>Sono state realizzate <em>data class</em> per standardizzare i dati contenuti nelle risorse osservabili Coap.</p>
    </li>
    <li>
      <p>Sia il sotto-sistema di <em>wasteservice.led</em> che quello di <em>wasteservice.gui</em> sono realizzati non usando il framework Qak, dato che l'interazione con il sistema centrale è limitata all'osservazione tramite connessioni Coap, il che semplifica la realizzazione dei due sotto-sistemi.</p>
    </li>
    <li>
      <p>
        <em>wasteservice.led</em> è un componente passivo, costituito da vari POJO, che osserva le risorse Trolley e WasteService e gestisce il led di conseguenza.</p>
    </li>
    <li>
      <p>
        <em>wasteservice.gui</em> è realizzato come webserver Spring Boot che serve una webapp, che viene aggiornata tramite WebSocket dagli Observer delle varie risorse osservate.</p>
    </li>
  </ul>
  <p>
    <img src="../img/architettura2_progetto.jpg" alt="modello architettura logica">
  </p>
  <p>I test dell'analisi sono stati adattati all'implementazione:</p>
  <ul>
    <li>
      <a href="../../wasteservice.statusgui/src/test/kotlin/it/unibo/lenziguerra/wasteservice/statusgui/TestGui.kt">TestGui.kt</a>
    </li>
    <li>
      <a href="../../wasteservice.led/src/test/kotlin/TestLed.kt">TestLed.kt</a>
    </li>
  </ul>
  <p>Possono essere eseguiti senza lanciare programmi esterni, a differenza dei test dello SPRINT 1.</p>
  <p>Vengono forniti i file Docker-compose elencati in seguito. Ci si può connettere alla porta 8080 per aprire l'interfaccia per i WasteTruck usata per inviare richieste alla porta 8090 per visualizzare l'ambiente virtuale del robot e alla porta 8095 per visualizzare WasteServiceStatusGUI.</p>
  <ul>
    <li>
      <p>
        <a href="../../wasteservice2_withledmock.yaml">wasteservice2_withledmock.yaml</a>: esegue tutto il sistema in locale, usando un mock per il Led che stampa lo stato attuale su standard output.</p>
    </li>
    <li>
      <p>
        <a href="../../wasteservice2_noled.yaml">wasteservice2_noled.yaml</a>: esegue il sistema senza la parte di wasteservice.led; essa va eseguita fuori da Docker sul Raspberry Pi, il quale IP va configurato dentro a questo file yaml nel campo <strong>wasteservice.led</strong> sotto <strong>extra_hosts</strong> del servizio <strong>wasteservice.statusgui</strong>. Per trasferire facilmente i file di distribuzione al Raspberry Pi viene fornito lo script <a href="../../wasteservice.led/scpDistrToRasp.sh">scpDistrToRasp.sh</a>, dove occorre configurare l'hostname/IP del raspberry al posto di <code>raspi</code> nei vari comandi.</p>
    </li>
  </ul>
</div></body>
