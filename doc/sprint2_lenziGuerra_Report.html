<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<style type="text/css">
    body {
        margin-right: 30px;
    }

    ;

    P {
        font-family: Tahoma;
        font-size: 10pt;
    }

    ;

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }

    a:hover {
        background-color: #cccccc;
    }


    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }

    h1,
    h2,
    h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }

    top {
        width: 100%;
    }


    #i {
        color: #ff1010;
    }

    tt {
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }

    em {
        font-family: "Arial";
    }

    bc {
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }

    ks {
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD;
        font-size: 90%;
    }

    kc {
        font-family: "Arial";
        font-weight: bold;
        color: #008000;
        font-size: 90%;
    }

    pre {
        font-family: "Consolas";
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }

    m {
        font-family: "Helvetica";
        line-height: 100%;
        font-size: 75%;
    }

    div.body {

        font-size: 18px;
    }

    k {
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }

    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }

    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }

    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }

    h4 {
        background-color: #ccffcc;
        font-size: 100%;
        width: 95%;
        border-radius: 5px;
        padding: 2px;
    }

    h5 {
        background-color: #d5ffb0;
        font-size: 100%;

    }

    div.req {
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }

    div.remark {
        background-color: #E3F2FD;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }

    table,
    th,
    td {
        border: 1px solid black;
        border-collapse: collapse;
    }

    ol,
    ul,
    li {
        margin: 0;
        margin-left: 10px;
        padding: 0;
    }

    table,
    th,
    td {
        border: 1px solid black;
    }

    img {
        border: 1.5px solid #d5f2ed
    }

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: black;
        background-color: transparent;
    }

    div.wrapdesc {
        width: 90%;
        margin: auto;
    }

    div.imagedesc {
        width: 85%;
        margin: auto;
    }
</style>

<head>

    <title>WasteService SPRINT 2 Report</title>
</head>

<body>
    <div class="w3-sidebar w3-bar-block w3-collapse w3-light-grey" style="width:10%; margin-top:-10px">
        <a class="w3-bar-item w3-button" href="#temafinale22">Requisiti</a>
        <a class="w3-bar-item w3-button" href="#analisi_requisiti">Analisi dei requisiti</a>
        <a class="w3-bar-item w3-button" href="#analisi_problema">Analisi del problema</a>
        <a class="w3-bar-item w3-button" href="#progetto">Progettazione e sviluppo</a>
        <a class="w3-bar-item w3-button" href="#testing">Testing</a>
        <a class="w3-bar-item w3-button" href="#deploy">Deployment</a>
        <a class="w3-bar-item w3-button" href="#sprint2_recap">Riassunto SPRINT 2</a>
    </div>
    <div style="margin-left:11%">
        <div id="top">
            <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font>
            </h1>

            <h1>WASTESERVICE - SPRINT 2 REPORT</h1>
            <h2>L. Guerra, F. Lenzi</h2>
        </div>

        <div class="body">
            <h2>Index</h2>

            <section id="index">
                <ul>
                    <li>
                        <a href="#temafinale22">Requisiti</a>
                    </li>
                    <li>
                        <a href="#analisi_requisiti">Analisi dei requisiti</a>
                    </li>
                    <li>
                        <a href="#analisi_problema">Analisi del problema</a>
                    </li>
                    <li>
                        <a href="#progetto">Progettazione e sviluppo</a>
                    </li>
                    <li>
                        <a href="#testing">Testing</a>
                    </li>
                    <li>
                        <a href="#deploy">Deployment</a>
                    </li>
                    <li>
                        <a href="#sprint2_recap">Riassunto SPRINT 2</a>
                    </li>
                </ul>
            </section>

            <h2>Requirements</h2>


            <section id="temafinale22">
                <p>A company intends to build a <span class="blue">WasteService</span> for the <em>separate collection
                        of
                        waste</em>, composed of a set of elements:</p>
                <ol class="arabic">
                    <li>
                        <p>a service area (rectangular, flat) that includes:</p>
                        <ul class="simple">
                            <li>
                                <p>an <span class="blue">INDOOR</span> port, to enter waste material</p>
                            </li>
                            <li>
                                <p>a <span class="blue">PlasticBox</span> container, devoted to store objects made of
                                    plastic, upto <strong>MAXPB</strong> kg of material.</p>
                            </li>
                            <li>
                                <p>a <span class="blue">GlassBox</span> container, devoted to store objects made of
                                    glass,
                                    upto <strong>MAXGB</strong> kg of material.</p>
                            </li>
                        </ul>
                        <p>The service area is free from internal obstacles, as shown in the following picture:</p>
                        <blockquote>
                            <div><a class="reference internal image-reference"
                                    href="https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/_images/WasteServiceRoom.PNG">
                                    <img alt="WasteServiceRoom.PNG" class="align-center"
                                        src="https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/_images/WasteServiceRoom.PNG"
                                        style="width: 60%;"></a>
                            </div>
                        </blockquote>
                    </li>
                    <li>
                        <p>a DDR robot working as a <span class="blue">transport trolley</span>, that is intially
                            situated
                            in its <span class="blue">HOME</span> location.
                            The transport trolley has the form of a square of side length <strong>RD</strong>.</p>
                        <p>The <cite>transport trolley</cite> is used to performa a <span class="blue">deposit
                                action</span>
                            that consists in the following phases:</p>
                        <ol class="arabic simple">
                            <li>
                                <p>pick up a waste-load from a <span class="blue">Waste truck</span> located on the
                                    <cite>INDOOR</cite>
                                </p>
                            </li>
                            <li>
                                <p>go from the <cite>INDOOR</cite> to the proper waste container</p>
                            </li>
                            <li>
                                <p>deposit the waste-load in the container</p>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <p>a <span class="blue">Service-manager</span> (an human being) which supervises the state of
                            the
                            service-area by using a
                            <span class="blue">WasteServiceStatusGUI</span>.
                        </p>
                    </li>
                    <li>
                        <p>a <span class="blue">Sonar</span> and a <span class="blue">Led</span> connected to a
                            RaspnerryPi.
                            The <cite>Led</cite> is used as a <em>warning devices</em>,
                            according to the following scheme:</p>
                        <ul class="simple">
                            <li>
                                <p>the <cite>Led</cite> is <strong>off</strong> when the <cite>transport trolley</cite>
                                    is
                                    at <cite>HOME</cite></p>
                            </li>
                            <li>
                                <p>the <cite>Led</cite> <strong>blinks</strong> while the <cite>transport trolley</cite>
                                    is
                                    moving</p>
                            </li>
                            <li>
                                <p>the <cite>Led</cite> is <strong>on</strong> when <cite>transport trolley</cite> is
                                    stopped.</p>
                            </li>
                        </ul>
                        <p>The <cite>Sonar</cite> is used as an ‘alarm device’: when it measures a distance less that a
                            prefixed value <strong>DLIMT</strong>,
                            the <cite>transport trolley</cite> must be stopped.
                            It will be resumed when <cite>Sonar</cite> detects again a distance higher than
                            <strong>DLIMT</strong>.
                        </p>
                    </li>
                </ol>
                <section id="tfrequirements">
                    <h3>TFRequirements</h3>
                    <p>The main goal of the <span class="blue">WasteService</span> software is to allow a <span
                            class="blue">Waste truck</span> to deposit its load of
                        <strong>TruckLoad</strong> kg plastic or glass in the proper container.
                    </p>
                    <p>The global story can be described as follows:</p>
                    <ol class="arabic simple">
                        <li>
                            <p>The <cite>Waste truck</cite> driver approaches the <cite>INDOOR</cite> and sends (using a
                                smart device) a request to store the load,
                                by specifyng the <cite>type of the material</cite> (plastic or glass) and its
                                <cite>TruckLoad</cite>.
                            </p>
                        </li>
                        <li>
                            <p>The <cite>WasteService</cite> sends the answer <em>loadaccept</em> if the final content
                                of
                                proper container will not surpass the
                                maximum value allowed (<em>MAXPB</em> or <em>MAXGB</em>). Otherwise, it sends the answer
                                <em>loadrejecetd</em> and the <cite>Waste truck</cite>
                                leaves the <cite>INDOOR</cite> area.
                            </p>
                        </li>
                        <li>
                            <p>When the load is accepted, the <cite>transport trolley</cite> reaches the
                                <cite>INDOOR</cite>, picks up the material, goes to the
                                proper container and settles the material. During this activity, the
                                <cite>WasteService</cite> <strong>blinks</strong> the <cite>Led</cite>
                            </p>
                        </li>
                        <li>
                            <p>When the deposit action is terminated, the <cite>transport trolley</cite> excutes another
                                deposit command (if any)
                                or returns to its <cite>HOME</cite>.</p>
                        </li>
                    </ol>
                    <p>The <cite>WasteService</cite> must create a <span class="blue">WasteServiceStatusGUI</span> that
                        shows to the <em>Service-manager</em>:</p>
                    <ul>
                        <li>
                            <p>the current state of the <cite>transport trolley</cite> and it position in the room</p>
                        </li>
                        <li>
                            <p>the current weigth of the material stored in the two waste-containers</p>
                        </li>
                        <li>
                            <p>the current state of the <cite>Led</cite></p>
                </section>
            </section>

            <h2>Requirement analysis</h2>

            <section id="analisi_requisiti">
                <p>Per ogni requisito analizzato in questo SPRINT è stato incluso un modello eseguibile in <a
                        href="#scelta-del-linguaggio-di-modellazione">Qak</a>.</p>
                <h3 id="requisiti-e-chiarimenti">Requisiti e chiarimenti</h3>
                <ul>
                    <li>
                        <p><strong>request</strong>: il <em>WasteService</em> accetta richieste di deposito da <em>Waste
                                truck</em> che arrivano nella zona specificata come INDOOR, che specificicano il tipo di
                            materiale da depositare</p>
                        <ul>
                            <li>il sistema può controllare se c'è spazio per un certo materiale: accetta (risposta
                                <em>loadaccept</em>), e rifiuta (risposta <em>loadrejected</em>) le richieste di
                                deposito in
                                caso contrario
                            </li>
                        </ul>
                        <ol>
                            <li>
                                <blockquote>
                                    <p>Domanda: le richieste possono essere gestite anche mentre il robot è in attività?
                                    </p>
                                </blockquote>
                                <p>Sì, potrebbe arrivare altro camion che chiede.</p>
                            </li>
                            <li>
                                <blockquote>
                                    <p>Domanda: solo un camion alla volta in INDOOR?</p>
                                </blockquote>
                                <p>Sì.</p>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <p><strong>deposit</strong>: il <em>trolley</em>, quando viene attivato, raccoglie i materiali a
                            INDOOR, e li deposita, in base al tipo, in GLASS BOX o PLASTIC BOX; questa è una <em>deposit
                                action</em>:</p>
                        <ol>
                            <li>Raccolta di rifiuti da <em>Waste truck</em> in INDOOR</li>
                            <li>Andare da INDOOR a contenitore rifiuti (* BOX)</li>
                            <li>Depositare rifiuti nel contenitore</li>
                        </ol>
                    </li>
                    <li>
                        <p><strong>indoor-more-requests</strong>: il <em>trolley</em>, terminata una <em>deposit
                                action</em>, torna a HOME solo se non ci sono altre richieste da gestire, sennò gestisce
                            subito la richiesta successiva andando a INDOOR</p>
                    </li>
                    <li>
                        <p><strong>led</strong>: nel sistema è presente un led che:</p>
                        <ul>
                            <li>è <em>acceso</em> se il <em>trolley</em> è a HOME</li>
                            <li><em>lampeggia</em> se il <em>trolley</em> è in attività</li>
                            <li>è <em>spento</em> se il trolley è in stato di <em>stop</em></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>sonar-stop</strong>: è presente un <em>sonar</em> che, se misura una distanza sotto
                            DLIMIT (valore prefissato), mette il <em>trolley</em> in stato di <em>stop</em> fino a che
                            la
                            distanza non torna a DLIMIT, nel qual caso il <em>trolley</em> riparte</p>
                        <ol>
                            <li>
                                <blockquote>
                                    <p>Domanda: cosa vuol dire precisamente <em>stop</em>? Torna a HOME o rimane lì?</p>
                                </blockquote>
                                <p>Si ferma e basta.</p>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <p><strong>gui</strong>: è presente una gui (<em>WasteServiceStatusGUI</em>) che mostra i
                            seguenti
                            dati:</p>
                        <ul>
                            <li>Stato del <em>trolley</em> e sua posizione</li>
                        </ul>
                        <ol>
                            <li>
                                <blockquote>
                                    <p>Domanda: Posizione del trolley: deve essere precisa o informazione più generale
                                        (INDOOR, in mezzo, HOME, ecc)?</p>
                                </blockquote>
                                <p>Basta una posizione più generale.</p>
                            </li>
                        </ol>
                        <ul>
                            <li>Carico depositato attuale (in kg)</li>
                            <li>Stato del Led (acceso/spento/lampeggiante)</li>
                        </ul>
                    </li>
                </ul>
                <p>In questo secondo SPRINT verranno analizzati i requisiti <strong>led</strong> e <strong>gui</strong>,
                    data la natura simile di interfaccia sullo stato del sistema e sviluppato il software annesso.</p>
                <h3 id="glossario">Glossario</h3>
                <ul>
                    <li>
                        <p><em>WasteService</em>: il servizio centrale che risponde alle richieste dei <em>waste
                                truck</em>
                        </p>
                    </li>
                    <li>
                        <p><em>Waste truck</em>: i camion che arrivano dall'esterno a depositare rifiuti</p>
                    </li>
                    <li>
                        <p>Area di servizio: <strong>INDOOR</strong>, <strong>PlasticBox</strong>,
                            <strong>GlassBox</strong>, aree definite nella creazione del sistema e punti di riferimento
                            per
                            il <em>trolley</em>. In particolare:
                        </p>
                        <ul>
                            <li>INDOOR: area dove i <em>waste truck</em> si fermano a lasciare il proprio carico,
                                facendo
                                una richiesta di deposito. Essa può contenere un <em>waste truck</em> alla volta</li>
                            <li>PlasticBox: area dove depositare la plastica</li>
                            <li>GlassBox: area dove depositare il vetro</li>
                        </ul>
                    </li>
                    <li>
                        <p><em>transport trolley</em> (o <em>trolley</em>): robot DDR (differential drive robot), di
                            dimensione approssimabile a quadrato di lato RD, usato per trasportare i rifiuti nel sistema
                        </p>
                    </li>
                    <li>
                        <p><em>Service-manager</em>: umano che supervisiona il sistema tramite la
                            <em>WasteServiceStatusGUI</em>
                        </p>
                    </li>
                    <li>
                        <p><em>Sonar</em>: sensore che misura distanza</p>
                    </li>
                    <li>
                        <p><em>Led</em>: spia luminosa</p>
                    </li>
                </ul>
                <h3 id="analisi-dei-requisiti-1">Analisi dei requisiti</h3>
                <h4 id="analisi-led">Analisi <strong>led</strong>:</h4>
                <p>La gestione del Led verrà fatta tramite il software fornito dal committente, gli script
                    <em>led25GpioTurnOn.sh</em> e <em>led25GpioTurnOff.sh</em>. L'azienda dispone già di una libreria
                    per
                    gestire tramite Java il Led con questi script, cioè <em>it.unibo.radarSystem22.domain</em>, quindi
                    sarà
                    opportuno utilizzarla.
                </p>
                <p>Dai requisiti, si evincono tre primitive che il led deve poter eseguire: accendersi, spegnersi, e
                    lampeggiare, che verranno chiamate <em>turnOn</em>, <em>turnOff</em>, <em>blink</em>. Il software
                    fornito e la libreria che lo controlla implementano solo le prime due, quindi questo <em>abstraction
                        gap</em> va colmato realizzando un componente intermedio, che chiameremo
                    <strong>BlinkLed</strong>,
                    che implementa la terza primitiva. Questo componente deve comunicare con il resto del sistema,
                    quindi
                    viene modellato come attore.
                </p>
                <p><img src="img/sprint2_req_led.png" alt="" /></p>
                <p>La natura precisa di questo attore lascia punti aperti che verranno gestiti in fase di analisi del
                    problema.</p>
                <p>Inoltre, il Led deve poter conoscere lo stato del Trolley.
                    Anche questo può essere implementato in più modi che rimangono un punto aperto.</p>
                <p><a href="../model.requisiti/src/led.qak">Modello eseguibile Led</a></p>
                <p>Intanto però, può già essere abbozzato un TestPlan:</p>
                <p><a href="../model.requisiti/test/it/unibo/TestLed.kt">Test plan Led</a></p>
                <h4 id="analisi-gui">Analisi <strong>gui</strong>:</h4>
                <p>Date le risorse pre-esistenti dell'azienda e il lavoro molto ridotto rispetto alle alternative, è
                    opportuno implementare <em>WasteServiceStatusGUI</em> come web-app.</p>
                <p>Anche in questo caso, dovendo comunicare con il resto del sistema, è opportuno modellarla come
                    attore:
                </p>
                <p><img src="img/sprint2_req_gui.png" alt="" /></p>
                <p>In questo documento, il nome <em>StatusGUI</em> verrà usato come sinonimo di
                    <em>WasteServiceStatusGUI</em> per comodità.
                </p>
                <p>Come per il Led, il tipo di comunicazione con il resto del sistema rimane un punto aperto.</p>
                <p><a href="../model.requisiti/src/gui.qak">Modello eseguibile Gui</a></p>
                <h3 id="materiale-fornito-dal-committente">Materiale fornito dal committente</h3>
                <ul>
                    <li>
                        <p>Robot DDR: viene fornita una componente software, <em>BasicRobot22</em>, che implementa
                            comandi
                            primitivi <em>MOVE = w | s | l | r | h</em>, e permette di fare <em>step</em> in avanti per
                            un
                            certo tempo.</p>
                    </li>
                    <li>
                        <p>Sonar: viene fornito un programma in C, <em>SonarAlone.c</em>, che stampa su standard output
                            la
                            distanza attualmente rilevata dal sonar, configurando le porte GPIO in questo modo:</p>
                        <ul>
                            <li>Porta VCC : pin fisico 4 (+5v)</li>
                            <li>Porta GND : pin fisico 6 (GND)</li>
                            <li>Porta TRIG: pin fisico 11 (WPI 0, BCM 17)</li>
                            <li>Porta ECHO: pin fisico 13 (WPI 2, BCM 27)</li>
                        </ul>
                    </li>
                    <li>
                        <p>Led: vengono forniti gli script bash e <em>led25GpioTurnOn.sh</em> e
                            <em>led25GpioTurnOff.sh</em>
                            per accendere e spegnere un Led connesso alla porta GPIO 25 di un Raspberry Pi.
                        </p>
                    </li>
                </ul>

            </section>



            <h2>Problem analysis</h2>

            <section id="analisi_problema">
                <h3 id="componenti">Componenti</h3>
                <h4 id="requisito-led-componenti">Requisito <strong>led</strong> - componenti</h4>
                <p>Emergono due opzioni principali su come gestire il Led:</p>
                <ul>
                    <li>
                        <p>Usare un solo attore BlinkLed che gestisce i dati di dominio e interagisce direttamente con
                            il
                            dispositivo tramite la libreria esistente e il software fornito. Quindi, questo singolo
                            componente riceverebbe i dati dello stato del Trolley e si occuperebbe di accensione e
                            spegnimento del Led.</p>
                    </li>
                    <li>
                        <p>Dividere gli incarichi tra due componenti:</p>
                        <ul>
                            <li>BlinkLed, che realizzerebbe le tre primitive di <em>turnOn</em>, <em>turnOff</em>,
                                <em>blink</em> e interagirebbe con il dispositivo tramite la libreria, attraverso
                                istruzioni
                                ricevute dall'esterno.
                            </li>
                            <li>LedController, che riceverebbe i dati dello stato del trolley e interagirebbe con
                                BlinkLed.
                            </li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Conclusione.</strong> Si ritiene migliore la seconda opzione, vale a dire <strong>dividere
                        gli
                        incarichi</strong>, visto che rispetta il principio di singola responsabilità. Inoltre, questo
                    permetterebbe il riutilizzo dell'attore BlinkLed in altri contesti, essendo agnostico al dominio.
                </p>
                <h3 id="interazione">Interazione</h3>
                <p>Il problema della comunicazione per <strong>led</strong> e <strong>gui</strong> è analogo, quindi
                    verranno analizzati insieme.</p>
                <p>Escludendo di usare comunicazione punto-punto come dispatch e richieste, data la scarsa espandibilità
                    e
                    la complicazione nella necessità di modificare ogni attore da analizzare, le opzioni attuali sono
                    due:
                </p>
                <ul>
                    <li>
                        <p>Usare eventi: si potrebbero aggiungere emissioni di eventi contenenti i dati di stato attuale
                            dei
                            vari attori di interesse per Led e WasteServiceStatusGui, incluso il Led i cui dati sono
                            visualizzati dalla Gui.</p>
                        <pre><code>Event trolleyStatus : trolleyStatus(STATUS,POS)
                                Event storageStatus : storageStatus(CONTENTS)
                                Event ledStatus : ledStatus(STATUS) //on|blink|off
                            </code></pre>
                    </li>
                    <li>
                        <p>Osservabilità: come detto nel progetto dello SPRINT 1, i vari attori sono osservabili tramite
                            COAP. Quindi un'opzione sarebbe rendere LedController e StatusGUI osservatori degli attori
                            rilevanti (e rendere osservabile il Led) e aggiungere alle informazioni osservabili degli
                            attori
                            di interesse eventuali dati mancanti.</p>
                    </li>
                </ul>
                <p><strong>Conclusione.</strong> Viene ritenuta come opzione migliore la seconda, l'uso di
                    <strong>observer</strong>, visto che gli attori creati nello SPRINT 1 sono già risorse osservabili
                    con
                    le informazioni necessarie; quindi, non sarebbe necessaria alcuna modifica al software già
                    sviluppato
                    per adempiere a questo requisito, il che sarebbe un grande vantaggio. Inoltre, il fatto che COAP sia
                    un
                    protocollo già definito renderebbe ancora più facile l'estendibilità.
                </p>
                <p>In luce di queste considerazioni, sono quindi aggiornati i modelli eseguibili di Led e Gui:</p>
                <ul>
                    <li><a href="../model.problema/src/pro_led.qak">Modello eseguibile Led</a></li>
                    <li><a href="../model.problema/src/pro_gui.qak">Modello eseguibile Gui</a></li>
                </ul>
                <p>Per realizzarli, è stata sviluppata una utility per Qak per permettere agli attori di agire da
                    osservatori, oltre che da risorse osservabili. Ulteriori dettagli sono presenti nel file <a
                        href="qakactor.observer.html">qakactor.observer.html</a>.</p>
                <h3 id="posizione-trolley">Posizione trolley</h3>
                <p>La posizione del Trolley, come da analisi dello Sprint 1, non è ad esso nota in termini di nomi del
                    dominio (&quot;home&quot;, &quot;indoor&quot;, ecc.) essendo esso usato come &quot;attuatore&quot;,
                    ma
                    solo in termini di coordinate numeriche. La componente che conosce la posizione del Trolley in
                    termini
                    di nomi dei luoghi è WasteService.</p>
                <p>Dovendo StatusGUI conoscere la posizione del Trolley in termini di nomi dei luoghi, si pongono due
                    possibilità:</p>
                <ul>
                    <li>
                        <p>StatusGUI potrebbe osservare anche WasteService, che comunque già fornisce questa
                            informazione
                            come risorsa.</p>
                    </li>
                    <li>
                        <p>StatusGUI potrebbe continuare ad osservare solo il Trolley e a decodificare il nome delle
                            posizioni dalla configurazione.</p>
                    </li>
                </ul>
                <p><strong>Conclusioni.</strong> È stato deciso il primo approccio, ritenuto più vicino al principio di
                    singola responsabilità; invece di mettere la logica di rilevazione del luogo dalla posizione in più
                    componenti, la si mette in un componente solo (WasteService) e si chiede ad esso lo stato attuale
                    del
                    dato.</p>
                <p>LedController ha un problema simile, cioè sapere se Trolley si trovi a HOME o meno: viene usata una
                    soluzione analoga.</p>
                <h3 id="architettura-logica">Architettura Logica</h3>
                <p>Ecco quindi l'architettura logica finale del sistema in generale per questo SPRINT:</p>
                <p><img src="img/sprint2_pro_arch.jpg" alt="modello architettura logica" /></p>
                <p><a href="../wasteservice.prototype/src/prototype_sprint2.qak"><strong>Modello eseguibile generale /
                            prototipo.</strong></a> Si noti come rispetto al modello eseguibile dello SPRINT 1, non sia
                    stato necessario modificare niente del codice preesistente ma sia bastato aggiungere gli
                    attori-osservatori.</p>
                <h3 id="test-plan">Test Plan</h3>
                <h4 id="testplan-led">TestPlan: led</h4>
                <p>Test plan in Kotlin: <a href="../wasteservice.prototype/test/it/unibo/TestLed.kt">TestLed.kt</a></p>
                <ul>
                    <li><strong>Test Led</strong>: creazione di server COAP &quot;fasullo&quot; allo stesso indirizzo
                        del
                        contesto del sistema principale osservato. Invio di dati che portano ai vari stati del Led, poi
                        verifica che questi stati siano stati raggiunti.</li>
                </ul>
                <h4 id="testplan-gui">TestPlan: gui</h4>
                <p>Test plan in Kotlin: <a href="../wasteservice.prototype/test/it/unibo/TestGui.kt">TestGui.kt</a>.
                    Nota:
                    lanciare un test alla volta, a causa di interazioni tra Qak e JUnit.</p>
                <ul>
                    <li><strong>Test Gui</strong>: creazione di server COAP &quot;fasullo&quot; allo stesso indirizzo
                        del
                        contesto del sistema principale osservato. Invio di dati che portano a vari stati della Gui, e
                        verifica che la pagina risultante venga modificata correttamente.</li>
                </ul>
            </section>

            <h2>Project</h2>


            <section id="progetto">
                <p>La progettazione e lo sviluppo delle componenti software stabilite in fase di analisi è stata divisa
                    in
                    questo modo:</p>
                <ul>
                    <li>BlinkLed, LedController: F. Lenzi</li>
                    <li>WasteServiceStatusGUI: L. Guerra</li>
                </ul>
                <h3 id="struttura-del-software">Struttura del software</h3>
                <p>Dato che entrambi i componenti non interagivano con il sistema Qak se non tramite l'osservazione
                    della
                    risorsa server COaP, sono stati realizzati come <strong>semplici oggetti</strong>, non attori,
                    dotati di
                    capacità di osservazione mediante una <code>CoapConnection</code> (libreria <em>unibo.comm22</em>)
                    che
                    sfrutta la libreria Californium per Coap.</p>
                <p>Questo permette di semplificare abbastanza la struttura, non richiedendo contesti di attori e
                    conseguenti
                    adattatori observer-attore come quello realizzato per rappresentare il modello dell'analisi.
                    Infatti, i
                    progetti dei due componenti non includono o conoscono neanche il framework Qak.</p>
                <p>I componenti sono stati contenuti in due nuovi progetti:</p>
                <ul>
                    <li><em>wasteservice.led</em>: contiene le classi corrispondenti a BlinkLed e LedController.</li>
                    <li><em>wasteservice.statusgui</em>: contiene il server Spring Boot che gestisce la WasteServiceGUI.
                    </li>
                </ul>
                <p>La struttura dei package diventa la seguente (evidenziati solo i cambiamenti importanti):</p>
                <ul>
                    <li>wasteservice.shared
                        <ul>
                            <li><em>it.unibo.lenziguerra.wasteservice</em> (aggiunti nuovi enumerativi, test fixture, e
                                classi minori)</li>
                            <li>it.unibo.lenziguerra.wasteservice.utils</li>
                            <li>
                                <ul>
                                    <li><em>it.unibo.lenziguerra.wasteservice.data</em> (classi dati, vedi sotto)</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>wasteservice.core
                        <ul>
                            <li>it.unibo.lenziguerra.wasteservice.wasteservice</li>
                            <li>it.unibo.lenziguerra.wasteservice.trolley</li>
                            <li>it.unibo.lenziguerra.wasteservice.storage</li>
                        </ul>
                    </li>
                    <li><strong>wasteservice.led</strong>
                        <ul>
                            <li><em>it.unibo.lenziguerra.wasteservice.led</em></li>
                        </ul>
                    </li>
                    <li><strong>wasteservice.statusgui</strong>
                        <ul>
                            <li><em>it.unibo.lenziguerra.wasteservice.statusgui</em></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="classi-dati">Classi dati</h3>
                <p>Come da analisi, non sarebbe servito modificare il progetto core per permettere il funzionamento dei
                    nuovi componenti, essendo gli attori già impostati per essere osservabili con dati rilevanti. Sono
                    state
                    comunque fatte modifiche minori, soprattutto per usare le <strong>classi dati</strong> aggiunte in
                    questo SPRINT.</p>
                <p>Per strutturare in modo più semplice e consistente il formato dei dati contenuti nelle risorse
                    osservabili COaP, questi dati sono stati incapsulati in apposite <em>data class</em> Kotlin,
                    contenute
                    in <em>wasteservice.shared:it.unibo.lenziguerra.wasteservice.data</em>. Esse hanno metodi
                    <code>fromProlog</code> e <code>toString</code> per convertire i dati da stringa osservata a dato di
                    dominio, con enumerativi vari rilevanti:
                </p>
                <pre><code class="language-Kotlin">data class TrolleyStatus (val status: State, val pos:
                        Array&lt;Int&gt;,
                        val contentType: WasteType?, val contentAmount: Float) {
                        enum class State {
                        WORK, STOPPED
                        }

                        companion object {
                        fun fromProlog(prolStr: String): TrolleyStatus {
                        [...]
                        }
                        }

                        override fun toString(): String {
                        return &quot;state(${status.toString().lowercase()})\npos(${pos[0]},${pos[1]})&quot; +
                        (contentType?.let { &quot;\ncontent($contentType,$contentAmount)&quot; } ?: &quot;&quot;)
                        }
                        }
                    </code></pre>
                <p>La stringa restituita da queste classi è quella che viene passata a <code>updateResource</code> nei
                    vari
                    attori (o equivalente per il Led).</p>
                <h3 id="led">Led</h3>
                <p>Il led, come da analisi, viene gestito tramite la libreria già realizzata
                    <em>it.unibo.radarSystem22.domain</em>, che a sua volta interagisce con il software del committente
                    (<em>led25GpioTurnOn.sh</em> e <em>led25GpioTurnOff.sh</em>).
                </p>
                <p>Come sopra i due componenti da analisi (BlinkLed e LedController) sono realizzati non come attori
                    Qak, ma
                    come POJO. In particolare, vengono realizate queste classi:</p>
                <ul>
                    <li>
                        <p><strong>BlinkLed</strong>: wrapper per le classi di <em>radarSystem22.domain</em>, che
                            permette
                            di impostare il led, oltre che ad acceso o spento, a uno stato di lampeggiamento, ed è
                            osservabile. Analogo all'attore BlinkLed in analisi.</p>
                    </li>
                    <li>
                        <p><strong>LedController</strong>: analogo a LedController in analisi, controlla un BlinkLed e
                            osserva Trolley e WasteService.</p>
                    </li>
                    <li>
                        <p><strong>BlinkLedCoapServer</strong>: un server COaP standalone, per rendere osservabile il
                            BlinkLed come risorsa.</p>
                    </li>
                    <li>
                        <p><strong>LedContainer</strong>: integra il sotto-sistema, istanziando e collegando i vari
                            componenti.</p>
                    </li>
                </ul>
                <h4 id="blinkled">BlinkLed</h4>
                <p>Da requisiti, il led deve poter essere impostato in stato di lampeggiamento, acceso, o spento,
                    realizzando le primitive <em>turnOn</em>, <em>turnOff</em>, e <em>blink</em>. L'interfaccia della
                    classe
                    BlinkLed, <code>IBlinkLed</code>, è quindi la seguente:</p>
                <pre><code class="language-Kotlin">interface IBlinkLed {
                        fun turnOn()
                        fun turnOff()
                        fun blink()

                        val status: BlinkLedState
                        var updateHandler: ((BlinkLedState) -&gt; Unit)?
                        }
                    </code></pre>
                <p><code>BlinkLedState</code> è un nuovo enumerativo che corrisponde ai tre stati possibili. La funzione
                    updateHandler, invece, è un callback che può essere impostato per rendere osservabile il
                    <code>BlinkLed</code>, chiamato a ogni cambiamento di stato.
                </p>
                <p>Il lampeggiamento in <code>BlinkLed</code> è realizzato creando un thread apposito al cambiamento di
                    stato:</p>
                <pre><code class="language-Kotlin">BlinkLedState.BLINKING -&gt; thread {
                        while (status == BlinkLedState.BLINKING) {
                        led.turnOn()
                        CommUtils.delay(500)
                        led.turnOff()
                        CommUtils.delay(500)
                        }
                        }
                    </code></pre>
                <p>esso non viene attivato se il Led sta già lampeggiando.</p>
                <h4 id="ledcontroller">LedController</h4>
                <p><code>LedController</code> riceve un <code>IBlinkLed</code>, e crea due connessioni Coap con il
                    contesto
                    Qak di <em>wasteservice.core</em> per osservare lo stato sia di WasteService che di Trolley, come da
                    analisi. Il funzionamento è analogo all'attore dell'analisi, con due handler Coap per gestire le due
                    risorse osservate.</p>
                <h4 id="blinkledcoapserver">BlinkLedCoapServer</h4>
                <p><code>BlinkLedCoapServer</code> è un semplice wrapper per <code>CoapServer</code> di Californium, che
                    contiene una <code>CoapResourceBlinkLed</code>, contenente un riferimento a <code>ILed</code>. Offre
                    una
                    funzione sendUpdates che invia aggiornamenti a tutti gli Observer della risorsa connessi. Espone la
                    risorsa all'Uri <em>/led</em>.</p>
                <h4 id="ledcontainer">LedContainer</h4>
                <p><code>LedContainer</code> si limita a configurare i vari componenti e istanziarli, e offrire il punto
                    di
                    ingresso del sistema. Il main, infatti, è lì contenuto. In particolare, crea un istanza di
                    <code>ILed</code> di <em>radarSystem22.domain</em> reale o mock in base alla configurazione della
                    libreria, contenuta in <em>DomainSystemConfig.json</em>.
                </p>
                <p>Inoltre, rende il led osservabile impostando il callback per lanciare <em>sendUpdates</em> nel
                    <code>BlinkLedCoapServer</code>:
                </p>
                <pre><code class="language-Kotlin">led.updateHandler = { ledServer.sendUpdates() }
                    </code></pre>
                <h3 id="wasteservicestatusgui">WasteServiceStatusGUI</h3>
                <p>Come da analisi, WasteServiceStatusGUI è stata implementata come web application. Il server web è
                    realizzato, come per WasteService, tramite il framework Spring Boot. In particolare, la pagina web
                    rimane connessa al server tramite <em>WebSocket</em>, per permettere aggiornamenti in diretta dei
                    dati
                    da monitorare senza aggiornare la pagina.</p>
                <p>L'osservazione dei dati è svolta dal <code>WebSocketHandler</code> Spring che gestisce le
                    connessioni,
                    implementato nella classe <code>StatusGuiWebsocketHandler</code>.</p>
                <h4 id="statusguiwebsockethandler">StatusGuiWebsocketHandler</h4>
                <p><code>StatusGuiWebsocketHandler</code> tiene traccia di ogni sessione di WebSocket attualmente
                    attiva, e
                    contiene le 4 <code>CoapConnection</code> ai componenti del sistema osservati (gli attori
                    <em>wasteservice</em>, <em>trolley</em>, <em>storagemanager</em> e il
                    <code>BlinkLedCoapServer</code>),
                    ciascuna gestita da un Observer. Gli Observer inviano a ogni sessione WebSocket attiva aggiornamenti
                    sui
                    dati ogni volta che la risorsa osservata cambia.
                </p>
                <p>L'handler in sè accetta un unico input da parte delle sessioni di WebSocket, vale a dire la stringa
                    <em>get</em>, alla quale risponde con aggiornamenti su tutti i dati. Questa viene usata al
                    caricamento
                    della pagina per inizializzare la StatusGUI.
                </p>
                <h4 id="observer">Observer</h4>
                <p>Gli observer sono estensioni di <code>CoapHandler</code> della libreria Californium, una classe per
                    ogni
                    risorsa osservata. Le classi sono presenti nel file <a
                        href="../wasteservice.statusgui/src/main/kotlin/it/unibo/lenziguerra/wasteservice/statusgui/Observers.kt">Observers.kt</a>.
                    Ogni observer contiene un riferimento alla lista di sessioni WebSocket attive, e invia aggiornamenti
                    alla ricezione dei dati.</p>
                <h3 id="altro">Altro</h3>
                <p>Sono state fatte altre modifiche minori a <em>wasteservice.core</em> e <em>wasteservice.shared</em>:
                </p>
                <ul>
                    <li>Aggiunto un dispatch <em>updateState</em> a Trolley per impostare il suo stato a
                        <em>stopped</em> in
                        caso di errore.
                    </li>
                    <li>Aggiunto gruppo source <em>testFixtures</em> in <em>wasteservice.shared</em> per condividere
                        librerie di testing con gli altri progetti senza includerle nella versione di distribuzione.
                    </li>
                    <li>Correzione all'uso di <code>WebSocketHandler</code> di Spring Boot in
                        <code>WasteServiceServer</code> per coerenza con StatusGUI, usa <em>@Component</em> e
                        <em>@AutoWired</em> per evitare di inizializzare l'handler 2 volte con Spring.
                    </li>
                </ul>
                <h3 id="test">Test</h3>
                <p>I test dell'analisi sono stati adattati al sistema, funzionando nello stesso modo, cioè creazione di
                    contesto Qak con attori mock la cui risorsa viene arbitrariamente pilotata nel test e osservata dai
                    componenti da testare. TestGui è eseguibile anche dalla classe di test, senza dover per forza
                    eseguire
                    un test alla volta.</p>
                <p>I test possono inoltre essere eseguiti senza avviare nessun software oltre al test, invece di
                    richiedere
                    WEnv/BasicRobot come nello SPRINT precedente. Questo grazie alla maggiore flessibilità data dalla
                    struttura ad Observer.</p>
                <ul>
                    <li><a
                            href="../wasteservice.statusgui/src/test/kotlin/it/unibo/lenziguerra/wasteservice/statusgui/TestGui.kt">TestGui.kt</a>
                    </li>
                    <li><a href="../wasteservice.led/src/test/kotlin/TestLed.kt">TestLed.kt</a></li>
                </ul>
                <p>È stato inoltre aggiunto un test per verificare il corretto funzionamento del lampeggiamento in
                    BlinkLed:
                </p>
                <ul>
                    <li><a href="../wasteservice.led/src/test/kotlin/BlinkLedTest.kt">BlinkLedTest.kt</a></li>
                </ul>
                <h3 id="struttura-del-sistema">Struttura del sistema</h3>
                <p>La struttura finale del sistema nello SPRINT 2 è riassunta in questo grafico:</p>
                <p><img src="img/architettura2_progetto.jpg" alt="modello architettura progetto" /></p>
                <p>Le connessioni di WasteServiceStatusGUI sono riassunte per testo per semplificare il grafico.</p>
                <h3 id="immagine-docker">Immagine Docker</h3>
                <p>Vengono forniti i file Docker-compose elencati in seguito. Ci si può connettere alla porta 8080 per
                    aprire l'interfaccia per i WasteTruck usata per inviare richieste, alla porta 8090 per visualizzare
                    l'ambiente virtuale del robot, e alla porta 8095 per visualizzare WasteServiceStatusGUI.</p>
                <ul>
                    <li>
                        <p><a href="../wasteservice2_withledmock.yaml">wasteservice2_withledmock.yaml</a>: esegue tutto
                            il
                            sistema in locale, usando un mock per il Led che stampa lo stato attuale su standard output.
                        </p>
                    </li>
                    <li>
                        <p><a href="../wasteservice2_noled.yaml">wasteservice2_noled.yaml</a>: esegue il sistema senza
                            la
                            parte di wasteservice.led; essa va eseguita fuori da Docker sul Raspberry Pi, il quale IP va
                            configurato dentro a questo file yaml nel campo <strong>wasteservice.led</strong> sotto
                            <strong>extra_hosts</strong> del servizio <strong>wasteservice.statusgui</strong>. Per
                            trasferire facilmente i file di distribuzione al Raspberry Pi viene fornito lo script <a
                                href="../wasteservice.led/scpDistrToRasp.sh">scpDistrToRasp.sh</a>, dove occorre
                            configurare
                            l'hostname/IP del raspberry al posto di <code>raspi</code> nei vari comandi.
                        </p>
                    </li>
                </ul>
            </section>

            <h2>Testing</h2>

            <section id="testing">
                <p>I test dell'analisi sono stati adattati al sistema, funzionando nello stesso modo, cioè creazione di
                    contesto Qak con attori mock la cui risorsa viene arbitrariamente pilotata nel test e osservata dai
                    componenti da testare. TestGui è eseguibile anche dalla classe di test, senza dover per forza
                    eseguire
                    un test alla volta.</p>
                <p>I test possono inoltre essere eseguiti senza avviare nessun software oltre al test, invece di
                    richiedere
                    WEnv/BasicRobot come nello SPRINT precedente. Questo grazie alla maggiore flessibilità data dalla
                    struttura ad Observer.</p>
                <ul>
                    <li><a
                            href="../wasteservice.statusgui/src/test/kotlin/it/unibo/lenziguerra/wasteservice/statusgui/TestGui.kt">TestGui.kt</a>
                    </li>
                    <li><a href="../wasteservice.led/src/test/kotlin/TestLed.kt">TestLed.kt</a></li>
                </ul>
                <p>È stato inoltre aggiunto un test per verificare il corretto funzionamento del lampeggiamento in
                    BlinkLed:
                </p>
                <ul>
                    <li><a href="../wasteservice.led/src/test/kotlin/BlinkLedTest.kt">BlinkLedTest.kt</a></li>
                </ul>
            </section>

            <h2>Deployment</h2>

            <section id="deployment">
                <p>Vengono forniti i file Docker-compose elencati in seguito. Ci si può connettere alla porta 8080 per
                    aprire l'interfaccia per i WasteTruck usata per inviare richieste, alla porta 8090 per visualizzare
                    l'ambiente virtuale del robot, e alla porta 8095 per visualizzare WasteServiceStatusGUI.</p>
                <ul>
                    <li>
                        <p><a href="../wasteservice2_withledmock.yaml">wasteservice2_withledmock.yaml</a>: esegue tutto
                            il
                            sistema in locale, usando un mock per il Led che stampa lo stato attuale su standard output.
                        </p>
                    </li>
                    <li>
                        <p><a href="../wasteservice2_noled.yaml">wasteservice2_noled.yaml</a>: esegue il sistema senza
                            la
                            parte di wasteservice.led; essa va eseguita fuori da Docker sul Raspberry Pi, il quale IP va
                            configurato dentro a questo file yaml nel campo <strong>wasteservice.led</strong> sotto
                            <strong>extra_hosts</strong> del servizio <strong>wasteservice.statusgui</strong>. Per
                            trasferire facilmente i file di distribuzione al Raspberry Pi viene fornito lo script <a
                                href="../wasteservice.led/scpDistrToRasp.sh">scpDistrToRasp.sh</a>, dove occorre
                            configurare
                            l'hostname/IP del raspberry al posto di <code>raspi</code> nei vari comandi.
                        </p>
                    </li>
                </ul>
            </section>

            <h2>Riassunto SPRINT 2</h2>

            <section id="sprint2_recap">
                <p>Il secondo SPRINT riguardava questi requisiti:</p>
                <ul>
                    <li><strong>led</strong>: nel sistema è presente un led che:
                        <ul>
                            <li>è <em>acceso</em> se il <em>trolley</em> è a HOME</li>
                            <li><em>lampeggia</em> se il <em>trolley</em> è in attività</li>
                            <li>è <em>spento</em> se il trolley è in stato di <em>stop</em></li>
                        </ul>
                    </li>
                    <li><strong>gui</strong>: è presente una gui (<em>WasteServiceStatusGUI</em>) che mostra i seguenti
                        dati:
                        <ul>
                            <li>Stato del <em>trolley</em> e sua posizione</li>
                        </ul>
                    </li>
                </ul>
                <h3 id="analisi">Analisi</h3>
                <p>In fase di analisi, è stato deciso di realizzare i due nuovi componenti sfruttando il pattern
                    Observer,
                    rendendoli Observer delle risorse osservabili realizzate nello SPRINT 1.</p>
                <p>Dopo la fase di analisi, l'architettura logica del sistema è stata così pensata:</p>
                <p><img src="img/sprint2_pro_arch.jpg" alt="modello architettura logica" /></p>
                <p><a href="../wasteservice.prototype/src/prototype_sprint2.qak"><strong>Modello eseguibile generale /
                            prototipo.</strong></a> Si noti come rispetto al modello eseguibile dello SPRINT 1, non sia
                    stato necessario modificare niente del codice preesistente ma sia bastato aggiungere gli
                    attori-osservatori.</p>
                <p>È stato realizzato un supporto a Qak per rendere un attore Observer di altri attori o risorse Coap,
                    <a href="qakactor.observer.html">qakactor.observer</a>.
                </p>
                <p>Sono usati per interagire con il led i componenti forniti dal committente,
                    <em>led25GpioTurnOn.sh</em> e
                    <em>led25GpioTurnOff.sh</em>, controllati con la libreria <em>it.unibo.radarSystem22.domain</em>
                    realizzata per progetti precedenti.
                </p>
                <p>Sono stati realizzati, in fase di analisi, dei test plan già eseguibili sfruttando il prototipo in
                    Qak,
                    per ogni requisito. Sono dettagliati nella sezione apposita, e collegati di seguito:</p>
                <ul>
                    <li><a href="../wasteservice.prototype/test/it/unibo/TestLed.kt">TestLed.kt</a></li>
                    <li><a href="../wasteservice.prototype/test/it/unibo/TestGui.kt">TestGui.kt</a>. Nota: lanciare un
                        test
                        alla volta, a causa di interazioni tra Qak e JUnit.</li>
                </ul>
                <h3 id="progetto">Progetto</h3>
                <p>I punti salienti della fase di sviluppo sono i seguenti:</p>
                <ul>
                    <li>
                        <p>Sono state realizzate <em>data class</em> per standardizzare i dati contenuti nelle risorse
                            osservabili Coap.</p>
                    </li>
                    <li>
                        <p>Sia il sotto-sistema di <em>wasteservice.led</em> che quello di <em>wasteservice.gui</em>
                            sono
                            realizzati non usando il framework Qak, dato che l'interazione con il sistema centrale è
                            limitata all'osservazione tramite connessioni Coap, il che semplifica la realizzazione dei
                            due
                            sotto-sistemi.</p>
                    </li>
                    <li>
                        <p><em>wasteservice.led</em> è un componente passivo, costituito da vari POJO, che osserva le
                            risorse Trolley e WasteService e gestisce il led di conseguenza.</p>
                    </li>
                    <li>
                        <p><em>wasteservice.gui</em> è realizzato come webserver Spring Boot che serve una webapp, che
                            viene
                            aggiornata tramite WebSocket dagli Observer delle varie risorse osservate.</p>
                    </li>
                </ul>
                <p><img src="img/architettura2_progetto.jpg" alt="modello architettura logica" /></p>
                <p>I test dell'analisi sono stati adattati all'implementazione:</p>
                <ul>
                    <li><a
                            href="../wasteservice.statusgui/src/test/kotlin/it/unibo/lenziguerra/wasteservice/statusgui/TestGui.kt">TestGui.kt</a>
                    </li>
                    <li><a href="../wasteservice.led/src/test/kotlin/TestLed.kt">TestLed.kt</a></li>
                </ul>
                <p>Possono essere eseguiti senza lanciare programmi esterni, a differenza dei test dello SPRINT 1.</p>
                <p>Vengono forniti i file Docker-compose elencati in seguito. Ci si può connettere alla porta 8080 per
                    aprire l'interfaccia per i WasteTruck usata per inviare richieste alla porta 8090 per visualizzare
                    l'ambiente virtuale del robot e alla porta 8095 per visualizzare WasteServiceStatusGUI.</p>
                <ul>
                    <li>
                        <p><a href="../wasteservice2_withledmock.yaml">wasteservice2_withledmock.yaml</a>: esegue tutto
                            il
                            sistema in locale, usando un mock per il Led che stampa lo stato attuale su standard output.
                        </p>
                    </li>
                    <li>
                        <p><a href="../wasteservice2_noled.yaml">wasteservice2_noled.yaml</a>: esegue il sistema senza
                            la
                            parte di wasteservice.led; essa va eseguita fuori da Docker sul Raspberry Pi, il quale IP va
                            configurato dentro a questo file yaml nel campo <strong>wasteservice.led</strong> sotto
                            <strong>extra_hosts</strong> del servizio <strong>wasteservice.statusgui</strong>. Per
                            trasferire facilmente i file di distribuzione al Raspberry Pi viene fornito lo script <a
                                href="../wasteservice.led/scpDistrToRasp.sh">scpDistrToRasp.sh</a>, dove occorre
                            configurare
                            l'hostname/IP del raspberry al posto di <code>raspi</code> nei vari comandi.
                        </p>
                    </li>
                </ul>
            </section>

            <h2>Maintenance</h2>


            <br /><br />
        </div>

        <div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
            Filippo Lenzi filippo.lenzi2@studio.unibo.it - Lorenzo Guerra lorenzo.guerra5@studio.unibo.it
            <!-- <img src="./img/emiglio.png" alt="mbot" width="15%" height="15%"> -->
        </div>
    </div>
</body>

</html>
