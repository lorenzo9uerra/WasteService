<h1 id="qakactor-observer">Qakactor Observer</h1>
<p>La utility Qakactor Observer è composta da una classe Kotlin <code>CoapObserverActor</code>, e una utility per utilizzarla da Qak <code>coapObserverUtil</code>. Permette di rendere degli attori Qak Observer di una risorsa Coap, sia generica che nello specifico altri attori Qak che sono risorse osservabili.</p>
<p>Il progetto è disponibile <a href="https://github.com/lnwor/WasteService/tree/main/qakactor.observer">su Github</a>.</p>
<p>Sempre su Github si può scaricare la <a href="https://github.com/lnwor/WasteService/blob/main/unibolibs/qakactor.observer-1.0.jar?raw=true">libreria in formato jar</a></p>
<h2 id="esempio">Esempio</h2>
<p>Un esempio di uso è il seguente:</p>
<pre><code>// Inizio file
Dispatch coapUpdate : coapUpdate(RESOURCE, VALUE)

// [...] interno di attore
State s0 initial {
   qrun coapObserverUtil.startObserving(myself, &quot;observable&quot;)
   /* qrun coapObserverUtil.startObserving(myself, &quot;ctx_observertest&quot;, &quot;observable&quot;) */
   /* qrun coapObserverUtil.startObservingHost(myself, &quot;localhost:9000&quot;, &quot;ctx_observertest/observable&quot;) */
}
Goto listen

State listen {
}
Transition t0 whenMsg coapUpdate -&gt; handleUpdate

State handleUpdate {
    onMsg(coapUpdate : coapUpdate(RESOURCE, VALUE)) {
        // [...]
    }
}
Goto listen
</code></pre>
<p>Un esempio completo è <a href="https://github.com/lnwor/WasteService/blob/main/qakactor.observer/test/observerdemo.qak">qui disponibile</a></p>
<h2 id="funzionamento-e-scelte-di-sviluppo">Funzionamento e scelte di sviluppo</h2>
<h3 id="handler-coap">Handler Coap</h3>
<p>La libreria fornisce una classe CoapHandler, <code>CoapObserverActor</code>, che riceve in costruzione un attore &quot;proprietario&quot;. Quando arrivano degli update Coap, li invia al proprietario incapsulati in un <strong>dispatch</strong> di tipo coapUpdate, che va quindi definito all'interno del file qak.</p>
<pre><code>Dispatch coapUpdate : coapUpdate(RESOURCE, VALUE)
</code></pre>
<p>Il proprietario può quindi gestire aggiornamenti Coap come un qualunque altro dispatch, distinguendo la risorsa che li invia tramite il primo parametro RESOURCE. Viene anche impostata come mittente del messaggio, ma è stato ritenuto più intuitivo per l'uso dentro Qak renderla disponibile anche all'interno di payloadArg(0).</p>
<p>È stato scelto di implementare l'osservazione come dispatch e non evento, per rappresentare la natura specifica dell'osservazione: non viene inviato il dato a tutti, ma solo a chi lo osserva.</p>
<h3 id="classe-di-utility">Classe di utility</h3>
<p>La classe fornita <code>coapObserverUtil</code> offre metodi statici per iniziare e finire di osservare una risorsa, sia per host e uri assoluti, sia in termini relativi a Qak fornendo nome dell'attore e opzionalmente del contesto (usando il contesto dell'attore osservante di default).</p>
<p>Possono essere semplicemente lanciati tramite <code>qrun</code> usando la keyword <code>myself</code> come primo argomento.</p>

