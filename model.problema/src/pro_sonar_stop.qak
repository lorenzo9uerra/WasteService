System wasteservice_pro_sonar_stop

Event sonarDistance : sonarDistance(DIST)
Dispatch trolleyStop : trolleyStop(_)
Dispatch trolleyResume : trolleyResume(_)

Context ctxpro_sonar_stop ip [host="localhost" port=8050]

QActor sonar_shim context ctxpro_sonar_stop {
	[#
		var Val = 200
	#]

	State scanWait initial {
		delay 500
	}
	Goto scan
	
	State scan {
		[# 
			var PrevVal = Val
			Val = (Val + kotlin.random.Random.nextInt(-60, 50)).coerceIn(0, 200) 
		#]
		if [# PrevVal != Val #] {
			println("\tSonar: detected distance $Val")
			emit sonarDistance : sonarDistance($Val)
			updateResource [# "$Val" #]			
		}
	}
	Goto scanWait
}

QActor sonar_interrupter context ctxpro_sonar_stop {
	[# 
	var prevDist: Float? = null
	var DLIMIT = 100
	#]
	State idle initial {
	}
	Transition t0 whenEvent sonarDistance -> handleDistance
	
	State handleDistance {
		printCurrentMessage
		onMsg ( sonarDistance : sonarDistance(DIST) ) {
			[# val dLimit = DLIMIT #]
			[# val dist = payloadArg(0).toFloat() #]
			// != e == false avendo anche null come possibile valore di let
			// non mandare resume all'inizio quando è null
			if [# dist <= dLimit && prevDist?.let {it > dLimit } != false #] {
				println("INVIO STOP")
				forward trolley -m trolleyStop : trolleyStop(_)
			}
			if [# dist > dLimit && prevDist?.let {it > dLimit } == false #] {
				println("INVIO RESUME")
				forward trolley -m trolleyResume : trolleyResume(_)
			}
			[# prevDist = dist #]
		}
	}
	Goto idle
}

QActor trolley context ctxpro_sonar_stop {
	State init initial{}
	Transition t0 whenTime 0 -> goingIndoor
				  whenInterrupt trolleyStop -> handleStop
 
	State goingIndoor{
		println("Going INDOOR")
		delay 2000
	}	
	Transition t0 whenTime 0 -> goingBox
				  whenInterrupt trolleyStop -> handleStop

  	State goingBox{
  		println("Going BOX")
		delay 2000
  	}
	Transition t0 whenTime 0 -> goingHome
				  whenInterrupt trolleyStop -> handleStop
  	
  	State goingHome{
  		println("Going HOME")
		delay 2000
  	}
	Transition t0 whenTime 0 -> goingIndoor
				  whenInterrupt trolleyStop -> handleStop
  	
  	State exitFromStop{
  		println("Trolley resumed!")
   		updateResource [# "resumed" #]
  		returnFromInterrupt
  	}
  	
  	State handleStop{
  		println("Trolley stopped!")
  		updateResource [# "stopped" #]
  	}
  	Transition t0 whenMsg trolleyResume -> exitFromStop
}

